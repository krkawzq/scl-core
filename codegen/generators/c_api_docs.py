"""
C API documentation skeleton generator.

Generates VitePress Markdown documentation templates with
TODO placeholders for manual documentation.
"""

from __future__ import annotations

from datetime import datetime
from pathlib import Path

from .base import Generator, GeneratedFile
from ..parser.c_types import (
    ParsedHeader,
    CFunction,
    CStruct,
    CEnum,
    CParameter,
)
from ..config import CodegenConfig


class CApiDocsGenerator(Generator):
    """
    Generator for C API documentation skeletons.

    Produces VitePress-compatible Markdown files with:
    - Function signatures and parameter tables
    - Struct and enum definitions
    - TODO placeholders for descriptions
    """

    def get_output_path(self, parsed: ParsedHeader) -> Path:
        """Get output path for documentation file."""
        # Determine relative path within c_api directory
        c_api_dir = self.config.c_api_dir_abs
        try:
            rel_path = parsed.path.relative_to(c_api_dir)
        except ValueError:
            rel_path = Path(parsed.path.name)

        # Convert .h to .md
        md_path = rel_path.with_suffix(".md")

        return self.config.docs_output_abs / md_path

    def generate(self, parsed: ParsedHeader) -> GeneratedFile:
        """Generate documentation skeleton."""
        output_path = self.get_output_path(parsed)
        content = self._generate_doc(parsed)

        return GeneratedFile(
            path=output_path,
            content=content,
            source=parsed.path,
        )

    def _generate_doc(self, parsed: ParsedHeader) -> str:
        """Generate complete documentation content."""
        lines = []

        # Title
        title = self._format_title(parsed.module_name)
        lines.append(f"# {title}")
        lines.append("")

        # Source reference
        lines.append(f"> Source: `{parsed.path}`")
        lines.append("")

        # Overview section
        lines.append("## Overview")
        lines.append("")
        lines.append("<!-- TODO: Add module overview description -->")
        lines.append("")

        # Functions
        if parsed.functions:
            lines.append("---")
            lines.append("")
            lines.append("## Functions")
            lines.append("")
            for func in parsed.functions:
                lines.extend(self._generate_function_doc(func))
                lines.append("")

        # Structures
        non_opaque_structs = [s for s in parsed.structs if not s.is_opaque]
        if non_opaque_structs:
            lines.append("---")
            lines.append("")
            lines.append("## Structures")
            lines.append("")
            for struct in non_opaque_structs:
                lines.extend(self._generate_struct_doc(struct))
                lines.append("")

        # Enums
        if parsed.enums:
            lines.append("---")
            lines.append("")
            lines.append("## Enumerations")
            lines.append("")
            for enum in parsed.enums:
                lines.extend(self._generate_enum_doc(enum))
                lines.append("")

        # Footer
        lines.append("---")
        lines.append("")
        timestamp = datetime.now().strftime("%Y-%m-%d")
        lines.append(f"*Generated by codegen on {timestamp}*")

        return "\n".join(lines)

    def _generate_function_doc(self, func: CFunction) -> list[str]:
        """Generate documentation for a function."""
        lines = []

        # Function name as heading
        lines.append(f"### `{func.name}`")
        lines.append("")

        # Signature in code block
        sig = self._format_signature(func)
        lines.append("```c")
        lines.append(sig)
        lines.append("```")
        lines.append("")

        # Brief description (from doc comment or placeholder)
        if func.doc:
            lines.append(func.doc)
        else:
            lines.append("<!-- TODO: Add function description -->")
        lines.append("")

        # Parameters table
        if func.parameters:
            lines.append("**Parameters:**")
            lines.append("")
            lines.append("| Name | Type | Direction | Description |")
            lines.append("|------|------|-----------|-------------|")
            for param in func.parameters:
                direction = self._infer_direction(param)
                lines.append(
                    f"| `{param.name}` | `{param.type}` | {direction} | "
                    f"<!-- TODO --> |"
                )
            lines.append("")

        # Return value
        lines.append("**Returns:**")
        lines.append("")
        lines.append(f"`{func.return_type}` - <!-- TODO: Add return description -->")
        lines.append("")

        return lines

    def _generate_struct_doc(self, struct: CStruct) -> list[str]:
        """Generate documentation for a struct."""
        lines = []

        lines.append(f"### `{struct.name}`")
        lines.append("")

        # Definition
        lines.append("```c")
        lines.append(f"typedef struct {struct.name} {{")
        for field in struct.fields:
            lines.append(f"    {field.type} {field.name};")
        lines.append(f"}} {struct.name};")
        lines.append("```")
        lines.append("")

        # Description
        if struct.doc:
            lines.append(struct.doc)
        else:
            lines.append("<!-- TODO: Add struct description -->")
        lines.append("")

        # Fields table
        if struct.fields:
            lines.append("**Fields:**")
            lines.append("")
            lines.append("| Field | Type | Description |")
            lines.append("|-------|------|-------------|")
            for field in struct.fields:
                lines.append(
                    f"| `{field.name}` | `{field.type}` | <!-- TODO --> |"
                )
            lines.append("")

        return lines

    def _generate_enum_doc(self, enum: CEnum) -> list[str]:
        """Generate documentation for an enum."""
        lines = []

        name = enum.name or "anonymous"
        lines.append(f"### `{name}`")
        lines.append("")

        # Description
        if enum.doc:
            lines.append(enum.doc)
        else:
            lines.append("<!-- TODO: Add enum description -->")
        lines.append("")

        # Values table
        if enum.values:
            lines.append("**Values:**")
            lines.append("")
            lines.append("| Name | Value | Description |")
            lines.append("|------|-------|-------------|")
            for val in enum.values:
                value_str = str(val.value) if val.value is not None else "-"
                lines.append(
                    f"| `{val.name}` | {value_str} | <!-- TODO --> |"
                )
            lines.append("")

        return lines

    def _format_title(self, module_name: str) -> str:
        """Format module name as title."""
        # Remove common prefixes
        if module_name.startswith("scl_"):
            module_name = module_name[4:]

        # Convert to Title Case
        return module_name.replace("_", " ").title()

    def _format_signature(self, func: CFunction) -> str:
        """Format function signature for display."""
        params = []
        for p in func.parameters:
            params.append(f"{p.type} {p.name}")

        params_str = ",\n    ".join(params) if len(params) > 2 else ", ".join(params)

        if len(params) > 2:
            return f"{func.return_type} {func.name}(\n    {params_str}\n);"
        else:
            return f"{func.return_type} {func.name}({params_str});"

    def _infer_direction(self, param: CParameter) -> str:
        """Infer parameter direction from type and name."""
        type_str = str(param.type)
        name = param.name.lower()

        # Check for output indicators
        if name.startswith("out_") or name.startswith("out"):
            return "[out]"

        # Check for const pointer (input)
        if "const" in type_str and "*" in type_str:
            return "[in]"

        # Non-const pointer could be output or in/out
        if "*" in type_str and "const" not in type_str:
            # Double pointer is usually output
            if type_str.count("*") >= 2:
                return "[out]"
            return "[in,out]"

        # Value type is input
        return "[in]"
