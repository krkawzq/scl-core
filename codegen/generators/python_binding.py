"""
Python ctypes binding generator.

Generates Python modules using decorator-based function registration.
Functions are registered once and can be used with any library variant.
"""

from __future__ import annotations

from datetime import datetime
from pathlib import Path
from typing import Optional

from .base import Generator, GeneratedFile
from ..parser.c_types import (
    ParsedHeader,
    CFunction,
    CStruct,
    CEnum,
    CTypedef,
    CType,
)
from ..config import CodegenConfig


class PythonBindingGenerator(Generator):
    """
    Generator for Python ctypes bindings using decorator registration.

    Produces clean Python modules that:
    - Register functions via @register decorator
    - Use string-based type specifications (resolved at runtime)
    - Support all library variants with a single code definition
    """

    def __init__(self, config: CodegenConfig):
        """Initialize the generator."""
        super().__init__(config)

    def get_output_path(self, parsed: ParsedHeader) -> Path:
        """Get output path for Python binding module."""
        c_api_dir = self.config.c_api_dir_abs
        try:
            rel_path = parsed.path.relative_to(c_api_dir)
        except ValueError:
            rel_path = Path(parsed.path.name)

        py_path = rel_path.with_suffix(".py")
        return self.config.python_output_abs / py_path

    def generate(self, parsed: ParsedHeader) -> GeneratedFile:
        """Generate Python binding module."""
        output_path = self.get_output_path(parsed)

        # Determine relative import path for _loader
        try:
            rel_to_bindings = output_path.relative_to(self.config.python_output_abs)
            depth = len(rel_to_bindings.parts) - 1
        except ValueError:
            depth = 0

        if depth > 0:
            loader_import = "." * (depth + 1) + "_loader"
        else:
            loader_import = "._loader"

        content = self._generate_module(parsed, loader_import)

        return GeneratedFile(
            path=output_path,
            content=content,
            source=parsed.path,
        )

    def _generate_module(self, parsed: ParsedHeader, loader_import: str) -> str:
        """Generate complete module content."""
        lines = []

        # Header
        lines.extend(self._generate_header(parsed))
        lines.append("")

        # Imports
        lines.extend(self._generate_imports(loader_import))
        lines.append("")
        lines.append("")

        # Enums
        if parsed.enums:
            lines.append("# " + "=" * 75)
            lines.append("# Enums")
            lines.append("# " + "=" * 75)
            lines.append("")
            for enum in parsed.enums:
                lines.extend(self._generate_enum(enum))
                lines.append("")

        # Structs
        structs_to_generate = [s for s in parsed.structs if not s.is_opaque]
        if structs_to_generate:
            lines.append("# " + "=" * 75)
            lines.append("# Structures")
            lines.append("# " + "=" * 75)
            lines.append("")
            for struct in structs_to_generate:
                lines.extend(self._generate_struct(struct))
                lines.append("")

        # Functions
        if parsed.functions:
            lines.append("# " + "=" * 75)
            lines.append("# Function Registrations")
            lines.append("# " + "=" * 75)
            lines.append("")
            for func in parsed.functions:
                lines.extend(self._generate_function(func))
                lines.append("")

        # Exports
        lines.append("# " + "=" * 75)
        lines.append("# Exports")
        lines.append("# " + "=" * 75)
        lines.append("")
        lines.extend(self._generate_exports(parsed))

        return "\n".join(lines)

    def _generate_header(self, parsed: ParsedHeader) -> list[str]:
        """Generate module header."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return [
            '"""',
            f"Auto-generated Python bindings for {parsed.module_name}",
            "",
            f"Source: {parsed.path}",
            "Generated by: codegen",
            f"Generated at: {timestamp}",
            "",
            "DO NOT EDIT - This file is automatically generated.",
            "",
            "Usage:",
            "    from scl._bindings._loader import lib_f64_i64 as lib",
            f"    from scl._bindings import {parsed.module_name}  # Register functions",
            "",
            "    # Now use any function via lib.function_name(...)",
            '"""',
        ]

    def _generate_imports(self, loader_import: str) -> list[str]:
        """Generate import statements."""
        return [
            "from __future__ import annotations",
            "",
            f"from {loader_import} import register",
        ]

    def _generate_enum(self, enum: CEnum) -> list[str]:
        """Generate enum class definition."""
        lines = []
        class_name = self._to_python_class_name(enum.name)

        lines.append(f"class {class_name}:")
        if enum.doc:
            lines.append(f'    """{enum.doc}"""')

        for val in enum.values:
            if val.value is not None:
                lines.append(f"    {val.name} = {val.value}")
            else:
                lines.append(f"    {val.name} = None")

        if not enum.values:
            lines.append("    pass")

        return lines

    def _generate_struct(self, struct: CStruct) -> list[str]:
        """Generate struct class definition."""
        lines = []
        class_name = self._to_python_class_name(struct.name)

        # For structs with fields, we need ctypes import
        lines.append("from ctypes import Structure, POINTER, c_void_p")
        lines.append("")
        lines.append(f"class {class_name}(Structure):")
        if struct.doc:
            lines.append(f'    """{struct.doc}"""')

        if struct.fields:
            lines.append("    _fields_ = [")
            for field in struct.fields:
                # Use string type for now, may need resolution
                lines.append(f'        ("{field.name}", c_void_p),  # {field.type}')
            lines.append("    ]")
        else:
            lines.append("    pass")

        return lines

    def _generate_function(self, func: CFunction) -> list[str]:
        """Generate function registration using decorator."""
        lines = []

        # Build argtypes list as strings
        argtypes = [self._format_c_type(str(p.type)) for p in func.parameters]
        argtypes_str = ", ".join(f'"{t}"' for t in argtypes)
        
        # Return type
        restype = self._format_c_type(str(func.return_type))

        # Build docstring
        doc_lines = []
        if func.doc:
            doc_lines.append(func.doc)
            doc_lines.append("")
        
        doc_lines.append("Args:")
        for param in func.parameters:
            doc_lines.append(f"    {param.name}: {param.type}")
        doc_lines.append("")
        doc_lines.append("Returns:")
        doc_lines.append(f"    {func.return_type}")
        
        doc_str = "\\n".join(doc_lines)

        # Generate decorator and placeholder function
        lines.append("@register(")
        lines.append(f'    "{func.name}",')
        lines.append(f"    argtypes=[{argtypes_str}],")
        lines.append(f'    restype="{restype}",')
        lines.append(f'    doc="{doc_str}",')
        lines.append(")")
        
        # Generate parameter signature for documentation
        param_names = [p.name for p in func.parameters]
        params_str = ", ".join(param_names) if param_names else ""
        
        lines.append(f"def {func.name}({params_str}):")
        lines.append(f'    """')
        if func.doc:
            lines.append(f"    {func.doc}")
            lines.append("")
        lines.append("    Args:")
        for param in func.parameters:
            lines.append(f"        {param.name}: {param.type}")
        lines.append("")
        lines.append("    Returns:")
        lines.append(f"        {func.return_type}")
        lines.append("")
        lines.append(f"    Note:")
        lines.append(f"        Call via lib.{func.name}() where lib is a Library instance.")
        lines.append('    """')
        lines.append("    pass  # Implementation provided by native library")

        return lines

    def _generate_exports(self, parsed: ParsedHeader) -> list[str]:
        """Generate __all__ export list."""
        exports = []

        for enum in parsed.enums:
            if enum.name:
                exports.append(self._to_python_class_name(enum.name))

        for struct in parsed.structs:
            if not struct.is_opaque:
                exports.append(self._to_python_class_name(struct.name))

        for func in parsed.functions:
            exports.append(func.name)

        lines = ["__all__ = ["]
        for name in sorted(exports):
            lines.append(f'    "{name}",')
        lines.append("]")

        return lines

    def _format_c_type(self, type_str: str) -> str:
        """Format C type string for registration (keep as-is for runtime resolution)."""
        return type_str.strip()

    def _to_python_class_name(self, name: str) -> str:
        """Convert C type name to Python class name."""
        if name.startswith("scl_"):
            name = name[4:]
        if name.endswith("_t"):
            name = name[:-2]
        parts = name.split("_")
        return "".join(p.capitalize() for p in parts)
