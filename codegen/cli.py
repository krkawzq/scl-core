"""
Command-line interface for codegen.

Usage:
    python -m codegen <command> [options]

Commands:
    python-bindings    Generate Python ctypes bindings
    c-api-docs         Generate C API documentation skeletons
    all                Generate all outputs
"""

from __future__ import annotations

import argparse
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional

from .config import CodegenConfig
from .parser import ClangParser, ParsedHeader
from .generators import PythonBindingGenerator, CApiDocsGenerator


# =============================================================================
# _loader.py Template - Lazy Library Manager with Decorator Registration
# =============================================================================

LOADER_TEMPLATE = '''"""
Multi-variant library loader for SCL native bindings.

Auto-generated by: codegen
Generated at: {timestamp}

This module provides a lazy-loading library manager with decorator-based
function registration. Each library variant (e.g., lib_f64_i64) loads on
first attribute access and automatically resolves types.

Usage:
    from scl._bindings._loader import lib_f64_i64 as lib
    from scl._bindings import algebra  # Import to register functions
    
    result = lib.scl_algebra_spmv(A, x, x_size, y, y_size, alpha, beta)

Available variants: {variant_list}
Default: lib (alias for lib_{default_variant})
"""

from __future__ import annotations

import ctypes
import os
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional, Dict, List, Any, Callable, Union
import threading

# =============================================================================
# Type Definitions
# =============================================================================

@dataclass(frozen=True)
class VariantInfo:
    """Information about a library variant."""
    suffix: str           # e.g., "f64_i64"
    real_type: str        # e.g., "float64"
    index_type: str       # e.g., "int64"
    ctypes_real: type     # ctypes type for real values
    ctypes_index: type    # ctypes type for index values


@dataclass
class FunctionSpec:
    """Specification for a registered function."""
    name: str
    argtypes: List[str]   # C type strings
    restype: str          # C return type string
    doc: Optional[str] = None
    wrapper: Optional[Callable] = None  # Optional Python wrapper


# =============================================================================
# Available Variants
# =============================================================================

VARIANTS: Dict[str, VariantInfo] = {{
{variants_dict}
}}

DEFAULT_VARIANT = "{default_variant}"

# =============================================================================
# Global Function Registry
# =============================================================================

_FUNCTION_REGISTRY: Dict[str, FunctionSpec] = {{}}
_registry_lock = threading.Lock()


# =============================================================================
# Type Resolution
# =============================================================================

# Static type mappings (independent of variant)
_STATIC_TYPE_MAP: Dict[str, type] = {{
    # Basic types
    "void": None,
    "int": ctypes.c_int,
    "unsigned int": ctypes.c_uint,
    "short": ctypes.c_short,
    "long": ctypes.c_long,
    "float": ctypes.c_float,
    "double": ctypes.c_double,
    "char": ctypes.c_char,
    "bool": ctypes.c_bool,
    "_Bool": ctypes.c_bool,
    
    # Fixed-width integers
    "int8_t": ctypes.c_int8,
    "int16_t": ctypes.c_int16,
    "int32_t": ctypes.c_int32,
    "int64_t": ctypes.c_int64,
    "uint8_t": ctypes.c_uint8,
    "uint16_t": ctypes.c_uint16,
    "uint32_t": ctypes.c_uint32,
    "uint64_t": ctypes.c_uint64,
    
    # Size types
    "size_t": ctypes.c_size_t,
    "ssize_t": ctypes.c_ssize_t,
    
    # SCL fixed types
    "scl_error_t": ctypes.c_int32,
    "scl_bool_t": ctypes.c_int,
    "scl_size_t": ctypes.c_size_t,
    
    # Handle types (opaque pointers)
    "scl_sparse_t": ctypes.c_void_p,
    "scl_dense_t": ctypes.c_void_p,
}}


def _resolve_type(type_str: str, variant_info: VariantInfo) -> Any:
    """
    Resolve a C type string to a ctypes type.
    
    Args:
        type_str: C type string (e.g., "scl_real_t*", "const int32_t*")
        variant_info: Variant info for dynamic type resolution
        
    Returns:
        ctypes type or POINTER wrapper
    """
    type_str = type_str.strip()
    
    # Handle void return
    if type_str == "void":
        return None
    
    # Handle const qualifier
    if type_str.startswith("const "):
        type_str = type_str[6:].strip()
    
    # Count and remove pointer stars
    pointer_depth = 0
    while type_str.endswith("*"):
        pointer_depth += 1
        type_str = type_str[:-1].strip()
    
    # Handle trailing const
    if type_str.endswith(" const"):
        type_str = type_str[:-6].strip()
    
    # Resolve base type
    if type_str == "scl_real_t":
        base_type = variant_info.ctypes_real
    elif type_str == "scl_index_t":
        base_type = variant_info.ctypes_index
    elif type_str in _STATIC_TYPE_MAP:
        base_type = _STATIC_TYPE_MAP[type_str]
    elif type_str == "char" and pointer_depth >= 1:
        # char* -> c_char_p
        return ctypes.c_char_p
    else:
        # Unknown type, default to void pointer
        base_type = ctypes.c_void_p
    
    # Apply pointer depth
    result = base_type
    for _ in range(pointer_depth):
        if result is None:
            result = ctypes.c_void_p
        else:
            result = ctypes.POINTER(result)
    
    return result


# =============================================================================
# Library Path Discovery
# =============================================================================

def _get_lib_name(suffix: str) -> str:
    """Get platform-specific library name."""
    if sys.platform == "win32":
        return f"scl_{{suffix}}.dll"
    elif sys.platform == "darwin":
        return f"libscl_{{suffix}}.dylib"
    else:
        return f"libscl_{{suffix}}.so"


def _find_library(suffix: str) -> Optional[Path]:
    """Find the native library for a given variant."""
    lib_name = _get_lib_name(suffix)
    
    search_paths = [
        Path(__file__).parent.parent / "libs",
        Path.cwd(),
    ]
    
    env_lib_dir = os.environ.get("SCL_LIB_DIR")
    if env_lib_dir:
        search_paths.append(Path(env_lib_dir))
    
    for base_path in search_paths:
        if not base_path.exists():
            continue
        lib_path = base_path / lib_name
        if lib_path.exists():
            return lib_path
    
    return None


# =============================================================================
# Library Class - Lazy Loading with Attribute Access
# =============================================================================

class Library:
    """
    Lazy-loading library manager with attribute-based function access.
    
    Functions are registered via the @register decorator and bound lazily
    on first access. Type resolution happens at bind time based on the
    library variant.
    
    Example:
        lib = Library("f64_i64")
        result = lib.scl_algebra_spmv(A, x, x_size, y, y_size, alpha, beta)
    """
    
    __slots__ = ("_variant", "_variant_info", "_lib", "_bound_funcs", "_lib_lock", "_bind_lock")
    
    def __init__(self, variant: str):
        """
        Initialize library for a specific variant.
        
        Args:
            variant: Variant suffix (e.g., "f64_i64")
            
        Raises:
            ValueError: If variant is not available
        """
        if variant not in VARIANTS:
            raise ValueError(
                f"Unknown variant '{{variant}}'. "
                f"Available: {{list(VARIANTS.keys())}}"
            )
        
        self._variant = variant
        self._variant_info = VARIANTS[variant]
        self._lib: Optional[ctypes.CDLL] = None
        self._bound_funcs: Dict[str, Callable] = {{}}
        self._lib_lock = threading.Lock()   # Lock for library loading
        self._bind_lock = threading.Lock()  # Lock for function binding
    
    @property
    def variant(self) -> str:
        """Get variant suffix."""
        return self._variant
    
    @property
    def variant_info(self) -> VariantInfo:
        """Get variant information."""
        return self._variant_info
    
    @property
    def real_type(self) -> type:
        """Get ctypes real type for this variant."""
        return self._variant_info.ctypes_real
    
    @property
    def index_type(self) -> type:
        """Get ctypes index type for this variant."""
        return self._variant_info.ctypes_index
    
    @property
    def is_loaded(self) -> bool:
        """Check if native library is loaded."""
        return self._lib is not None
    
    @property
    def _native(self) -> ctypes.CDLL:
        """Lazy-load and return native library."""
        if self._lib is None:
            with self._lib_lock:
                if self._lib is None:
                    self._lib = self._load_library()
        return self._lib
    
    def _load_library(self) -> ctypes.CDLL:
        """Load the native library."""
        lib_path = _find_library(self._variant)
        
        if lib_path is None:
            lib_name = _get_lib_name(self._variant)
            raise RuntimeError(
                f"Cannot find native library '{{lib_name}}'. "
                f"Ensure the library is compiled and located in one of:\\n"
                f"  - python/scl/libs/\\n"
                f"  - Current working directory\\n"
                f"  - SCL_LIB_DIR environment variable"
            )
        
        try:
            return ctypes.CDLL(str(lib_path))
        except OSError as e:
            raise RuntimeError(
                f"Failed to load native library '{{lib_path}}': {{e}}"
            ) from e
    
    def _bind_function(self, name: str) -> Callable:
        """Bind a function from the registry."""
        if name not in _FUNCTION_REGISTRY:
            raise AttributeError(
                f"Function '{{name}}' is not registered. "
                f"Make sure to import the corresponding binding module."
            )
        
        spec = _FUNCTION_REGISTRY[name]
        
        # Get native function
        try:
            func = getattr(self._native, name)
        except AttributeError:
            raise AttributeError(
                f"Function '{{name}}' not found in native library. "
                f"Library may need to be recompiled."
            )
        
        # Set argument types
        func.argtypes = [
            _resolve_type(t, self._variant_info) 
            for t in spec.argtypes
        ]
        
        # Set return type
        func.restype = _resolve_type(spec.restype, self._variant_info)
        
        # If there's a wrapper, use it
        if spec.wrapper is not None:
            return lambda *args, **kwargs: spec.wrapper(func, *args, **kwargs)
        
        return func
    
    def __getattr__(self, name: str) -> Callable:
        """Get a bound function by name."""
        # Avoid infinite recursion for special attributes
        if name.startswith("_"):
            raise AttributeError(f"'Library' object has no attribute '{{name}}'")
        
        # Use object.__getattribute__ to safely access internal attributes
        try:
            bound_funcs = object.__getattribute__(self, "_bound_funcs")
            bind_lock = object.__getattribute__(self, "_bind_lock")
        except AttributeError:
            raise AttributeError(f"'Library' object has no attribute '{{name}}'")
        
        # Check cache first (without lock for read)
        if name in bound_funcs:
            return bound_funcs[name]
        
        # Bind and cache (with lock for write)
        with bind_lock:
            if name not in bound_funcs:
                bound_funcs[name] = self._bind_function(name)
            return bound_funcs[name]
    
    def __repr__(self) -> str:
        loaded = "loaded" if self.is_loaded else "not loaded"
        return f"<Library variant='{{self._variant}}' {{loaded}}>"
    
    def get_config(self) -> dict:
        """Get configuration summary."""
        lib_path = _find_library(self._variant)
        return {{
            "variant": self._variant,
            "real_type": self._variant_info.real_type,
            "index_type": self._variant_info.index_type,
            "lib_name": _get_lib_name(self._variant),
            "lib_path": str(lib_path) if lib_path else "NOT FOUND",
            "is_loaded": self.is_loaded,
            "bound_functions": list(self._bound_funcs.keys()),
        }}


# =============================================================================
# Function Registration Decorator
# =============================================================================

def register(
    name: str,
    argtypes: List[str],
    restype: str,
    doc: Optional[str] = None,
):
    """
    Register a function specification for all library variants.
    
    This decorator registers the function signature so that Library
    instances can bind it lazily with correct type resolution.
    
    Args:
        name: C function name (e.g., "scl_algebra_spmv")
        argtypes: List of C type strings for arguments
        restype: C return type string
        doc: Optional documentation string
        
    Example:
        @register(
            "scl_algebra_spmv",
            argtypes=["scl_sparse_t", "const scl_real_t*", "scl_size_t", 
                      "scl_real_t*", "scl_size_t", "scl_real_t", "scl_real_t"],
            restype="scl_error_t",
            doc="General SpMV: y = alpha * A * x + beta * y",
        )
        def scl_algebra_spmv(A, x, x_size, y, y_size, alpha, beta):
            pass  # Implementation provided by native library
    """
    def decorator(func: Callable) -> Callable:
        with _registry_lock:
            _FUNCTION_REGISTRY[name] = FunctionSpec(
                name=name,
                argtypes=argtypes,
                restype=restype,
                doc=doc or func.__doc__,
                wrapper=None,
            )
        # Return a placeholder that documents the function
        func.__doc__ = doc or func.__doc__
        func._scl_registered = True
        func._scl_name = name
        return func
    return decorator


def get_registered_functions() -> List[str]:
    """Get list of all registered function names."""
    return list(_FUNCTION_REGISTRY.keys())


def is_registered(name: str) -> bool:
    """Check if a function is registered."""
    return name in _FUNCTION_REGISTRY


# =============================================================================
# Pre-defined Library Instances
# =============================================================================

{lib_instances}

# Default library (alias)
lib = lib_{default_variant}


# =============================================================================
# Convenience Functions
# =============================================================================

def get_library(variant: str) -> Library:
    """
    Get a library instance for a variant.
    
    Args:
        variant: Variant suffix (e.g., "f64_i64")
        
    Returns:
        Library instance
    """
    # Check pre-defined instances first
    instance_name = f"lib_{{variant}}"
    if instance_name in globals():
        return globals()[instance_name]
    
    # Create new instance
    return Library(variant)


def get_available_variants() -> List[str]:
    """Get list of available variant suffixes."""
    return list(VARIANTS.keys())


# =============================================================================
# Exports
# =============================================================================

__all__ = [
    # Types
    "VariantInfo",
    "FunctionSpec",
    "Library",
    # Registration
    "register",
    "get_registered_functions",
    "is_registered",
    # Variants info
    "VARIANTS",
    "DEFAULT_VARIANT",
    "get_available_variants",
    # Library instances
{lib_exports}
    "lib",
    "get_library",
]
'''


def _generate_variants_dict(config: CodegenConfig) -> str:
    """Generate VARIANTS dictionary content."""
    lines = []
    
    for variant in config.variants.variants:
        suffix = variant.suffix
        real_type = variant.real_type
        index_type = variant.index_type
        
        ctypes_real_map = {
            "float16": "ctypes.c_uint16",
            "float32": "ctypes.c_float",
            "float64": "ctypes.c_double",
        }
        ctypes_index_map = {
            "int16": "ctypes.c_int16",
            "int32": "ctypes.c_int32",
            "int64": "ctypes.c_int64",
        }
        
        lines.append(f'    "{suffix}": VariantInfo(')
        lines.append(f'        suffix="{suffix}",')
        lines.append(f'        real_type="{real_type}",')
        lines.append(f'        index_type="{index_type}",')
        lines.append(f'        ctypes_real={ctypes_real_map.get(real_type, "ctypes.c_double")},')
        lines.append(f'        ctypes_index={ctypes_index_map.get(index_type, "ctypes.c_int64")},')
        lines.append(f'    ),')
    
    return "\n".join(lines)


def _generate_lib_instances(config: CodegenConfig) -> str:
    """Generate pre-defined library instances."""
    lines = []
    for variant in config.variants.variants:
        suffix = variant.suffix
        lines.append(f'lib_{suffix} = Library("{suffix}")')
    return "\n".join(lines)


def _generate_lib_exports(config: CodegenConfig) -> str:
    """Generate library exports for __all__."""
    lines = []
    for variant in config.variants.variants:
        suffix = variant.suffix
        lines.append(f'    "lib_{suffix}",')
    return "\n".join(lines)


def generate_loader_module(config: CodegenConfig, verbose: bool = False) -> bool:
    """Generate the _loader.py module."""
    output_path = config.python_output_abs / "_loader.py"

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    variant_list = ", ".join(config.variants.variant_suffixes)
    variants_dict = _generate_variants_dict(config)
    lib_instances = _generate_lib_instances(config)
    lib_exports = _generate_lib_exports(config)

    content = LOADER_TEMPLATE.format(
        timestamp=timestamp,
        variant_list=variant_list,
        default_variant=config.variants.default_variant,
        variants_dict=variants_dict,
        lib_instances=lib_instances,
        lib_exports=lib_exports,
    )

    output_path.parent.mkdir(parents=True, exist_ok=True)

    if output_path.exists() and not config.generation.overwrite:
        if verbose:
            print(f"  Skipping _loader.py (exists)")
        return False

    output_path.write_text(content)

    if verbose:
        print(f"  Generated: {output_path}")

    return True


def find_headers(
    c_api_dir: Path,
    pattern: str = "*.h",
    exclude_dirs: Optional[set[str]] = None,
) -> list[Path]:
    """Find all header files in C API directory."""
    if exclude_dirs is None:
        exclude_dirs = {"__pycache__", ".git"}

    headers = []
    for path in c_api_dir.rglob(pattern):
        if any(excl in path.parts for excl in exclude_dirs):
            continue
        headers.append(path)

    return sorted(headers)


def generate_python_bindings(
    config: CodegenConfig,
    input_path: Optional[Path] = None,
    verbose: bool = False,
) -> int:
    """Generate Python bindings."""
    # Generate _loader.py first
    if verbose:
        print("Generating _loader.py...")
    loader_generated = generate_loader_module(config, verbose=verbose)
    if loader_generated and verbose:
        print("  _loader.py generated successfully")

    # Find headers
    if input_path:
        if input_path.is_file():
            headers = [input_path]
        else:
            headers = find_headers(input_path)
    else:
        headers = find_headers(config.c_api_dir_abs)

    if not headers:
        print("No header files found.")
        return 1

    if verbose:
        print(f"Found {len(headers)} header files")

    # Parse headers
    parser = ClangParser(
        include_dirs=[config.project_root],
    )

    generator = PythonBindingGenerator(config)

    success_count = 0
    error_count = 0

    for header in headers:
        try:
            if verbose:
                print(f"Parsing: {header}")

            parsed = parser.parse(header)

            if not parsed.has_content:
                if verbose:
                    print(f"  Skipping (no content)")
                continue

            result = generator.generate(parsed)

            result.path.parent.mkdir(parents=True, exist_ok=True)

            if result.path.exists() and not config.generation.overwrite:
                if verbose:
                    print(f"  Skipping (exists): {result.path}")
                continue

            result.path.write_text(result.content)

            if verbose:
                print(f"  Generated: {result.path}")

            success_count += 1

        except Exception as e:
            print(f"Error processing {header}: {e}", file=sys.stderr)
            error_count += 1

    if loader_generated:
        success_count += 1

    print(f"\nGenerated {success_count} files, {error_count} errors")
    return 0 if error_count == 0 else 1


def generate_c_api_docs(
    config: CodegenConfig,
    input_path: Optional[Path] = None,
    verbose: bool = False,
) -> int:
    """Generate C API documentation skeletons."""
    if input_path:
        if input_path.is_file():
            headers = [input_path]
        else:
            headers = find_headers(input_path)
    else:
        headers = find_headers(config.c_api_dir_abs)

    if not headers:
        print("No header files found.")
        return 1

    if verbose:
        print(f"Found {len(headers)} header files")

    parser = ClangParser(
        include_dirs=[config.project_root],
    )

    generator = CApiDocsGenerator(config)

    success_count = 0
    error_count = 0

    for header in headers:
        try:
            if verbose:
                print(f"Parsing: {header}")

            parsed = parser.parse(header)

            if not parsed.has_content:
                if verbose:
                    print(f"  Skipping (no content)")
                continue

            result = generator.generate(parsed)

            result.path.parent.mkdir(parents=True, exist_ok=True)

            if result.path.exists() and not config.generation.overwrite:
                if verbose:
                    print(f"  Skipping (exists): {result.path}")
                continue

            result.path.write_text(result.content)

            if verbose:
                print(f"  Generated: {result.path}")

            success_count += 1

        except Exception as e:
            print(f"Error processing {header}: {e}", file=sys.stderr)
            error_count += 1

    print(f"\nGenerated {success_count} files, {error_count} errors")
    return 0 if error_count == 0 else 1


def main(argv: Optional[list[str]] = None) -> int:
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        prog="codegen",
        description="SCL-Core Code Generator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python -m codegen python-bindings
  python -m codegen python-bindings -i scl/binding/c_api/hvg.h
  python -m codegen c-api-docs
  python -m codegen --config codegen.toml all
""",
    )

    parser.add_argument("--config", "-c", type=Path, help="Configuration file")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    parser.add_argument("--overwrite", action="store_true", help="Overwrite existing files")

    subparsers = parser.add_subparsers(dest="command", required=True)

    py_parser = subparsers.add_parser("python-bindings", help="Generate Python ctypes bindings")
    py_parser.add_argument("--input", "-i", type=Path, help="Input header file or directory")
    py_parser.add_argument("--output", "-o", type=Path, help="Output directory")

    docs_parser = subparsers.add_parser("c-api-docs", help="Generate C API documentation")
    docs_parser.add_argument("--input", "-i", type=Path, help="Input header file or directory")
    docs_parser.add_argument("--output", "-o", type=Path, help="Output directory")

    all_parser = subparsers.add_parser("all", help="Generate all outputs")

    args = parser.parse_args(argv)

    config = CodegenConfig.load(args.config)

    if args.overwrite:
        config.generation.overwrite = True

    if hasattr(args, "output") and args.output:
        if args.command == "python-bindings":
            config.paths.python_output = args.output
        elif args.command == "c-api-docs":
            config.paths.docs_output = args.output

    if args.command == "python-bindings":
        return generate_python_bindings(config, input_path=getattr(args, "input", None), verbose=args.verbose)
    elif args.command == "c-api-docs":
        return generate_c_api_docs(config, input_path=getattr(args, "input", None), verbose=args.verbose)
    elif args.command == "all":
        ret1 = generate_python_bindings(config, verbose=args.verbose)
        ret2 = generate_c_api_docs(config, verbose=args.verbose)
        return max(ret1, ret2)

    return 1


if __name__ == "__main__":
    sys.exit(main())
