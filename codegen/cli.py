"""
Command-line interface for codegen.

Usage:
    python -m codegen <command> [options]

Commands:
    python-bindings    Generate Python ctypes bindings
    c-api-docs         Generate C API documentation skeletons
    all                Generate all outputs
"""

from __future__ import annotations

import argparse
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional

from .config import CodegenConfig
from .parser import ClangParser, ParsedHeader
from .generators import PythonBindingGenerator, CApiDocsGenerator


# =============================================================================
# _types.py Template - Type Markers for Function Signatures
# =============================================================================

TYPES_TEMPLATE = '''"""
Type markers for SCL function signatures.

Auto-generated by: codegen
Generated at: {timestamp}

These types are used as annotations in function signatures and are
resolved to actual ctypes at Library instantiation time.

Usage:
    from ._types import SparseHandle, Ptr, Real, Index, Size, Error
    
    @register
    def scl_function(matrix: SparseHandle, data: Ptr[Real], n: Size) -> Error:
        ...
"""

from __future__ import annotations

from typing import TypeVar, Generic, TYPE_CHECKING

# =============================================================================
# Type Markers (resolved at runtime based on variant)
# =============================================================================

class _TypeMarker:
    """Base class for type markers."""
    __slots__ = ()


class Real(_TypeMarker):
    """Floating-point type (float32 or float64 depending on variant)."""
    __slots__ = ()


class Index(_TypeMarker):
    """Index type (int16, int32, or int64 depending on variant)."""
    __slots__ = ()


class Size(_TypeMarker):
    """Size type (always size_t)."""
    __slots__ = ()


class Error(_TypeMarker):
    """Error code type (always int32)."""
    __slots__ = ()


class Bool(_TypeMarker):
    """Boolean type (always int)."""
    __slots__ = ()


class Char(_TypeMarker):
    """Character type."""
    __slots__ = ()


class Int8(_TypeMarker):
    """8-bit signed integer."""
    __slots__ = ()


class Int16(_TypeMarker):
    """16-bit signed integer."""
    __slots__ = ()


class Int32(_TypeMarker):
    """32-bit signed integer."""
    __slots__ = ()


class Int64(_TypeMarker):
    """64-bit signed integer."""
    __slots__ = ()


class UInt8(_TypeMarker):
    """8-bit unsigned integer."""
    __slots__ = ()


class UInt16(_TypeMarker):
    """16-bit unsigned integer."""
    __slots__ = ()


class UInt32(_TypeMarker):
    """32-bit unsigned integer."""
    __slots__ = ()


class UInt64(_TypeMarker):
    """64-bit unsigned integer."""
    __slots__ = ()


class Float(_TypeMarker):
    """32-bit float (always c_float)."""
    __slots__ = ()


class Double(_TypeMarker):
    """64-bit float (always c_double)."""
    __slots__ = ()


class Void(_TypeMarker):
    """Void type."""
    __slots__ = ()


# =============================================================================
# Handle Types (Opaque Pointers)
# =============================================================================

class SparseHandle(_TypeMarker):
    """Handle to sparse matrix (scl_sparse_t)."""
    __slots__ = ()


class DenseHandle(_TypeMarker):
    """Handle to dense matrix (scl_dense_t)."""
    __slots__ = ()


# =============================================================================
# Pointer Type (Generic)
# =============================================================================

T = TypeVar("T", bound=_TypeMarker)


class Ptr(Generic[T]):
    """
    Pointer to a type.
    
    Usage:
        Ptr[Real]  -> POINTER(c_double) or POINTER(c_float)
        Ptr[Int32] -> POINTER(c_int32)
    """
    __slots__ = ()
    __origin__ = None  # For typing introspection
    
    def __class_getitem__(cls, item):
        # Return a special marker that can be introspected
        return _PtrType(item)


class _PtrType:
    """Internal pointer type representation."""
    __slots__ = ("pointee",)
    
    def __init__(self, pointee):
        self.pointee = pointee
    
    def __repr__(self):
        return f"Ptr[{{self.pointee.__name__}}]"


class ConstPtr(Generic[T]):
    """Const pointer (same as Ptr for ctypes, but documents intent)."""
    __slots__ = ()
    
    def __class_getitem__(cls, item):
        return _PtrType(item)


class CString(_TypeMarker):
    """C string (const char*)."""
    __slots__ = ()


class MutableCString(_TypeMarker):
    """Mutable C string (char*)."""
    __slots__ = ()


# =============================================================================
# Exports
# =============================================================================

__all__ = [
    # Scalar types
    "Real", "Index", "Size", "Error", "Bool", "Char",
    "Int8", "Int16", "Int32", "Int64",
    "UInt8", "UInt16", "UInt32", "UInt64",
    "Float", "Double", "Void",
    # Handle types
    "SparseHandle", "DenseHandle",
    # Pointer types
    "Ptr", "ConstPtr", "CString", "MutableCString",
    # Type variable
    "T",
]
'''


# =============================================================================
# _loader.py Template - Optimized Library with Pre-binding
# =============================================================================

LOADER_TEMPLATE = '''"""
Optimized library loader for SCL native bindings.

Auto-generated by: codegen
Generated at: {timestamp}

Features:
- Pre-binding: All functions are bound at Library instantiation
- Type-hint based: Uses Python annotations for type resolution
- Zero runtime overhead: No string parsing during function calls
- Thread-safe: Safe for concurrent use

Available variants: {variant_list}
Default: lib (alias for lib_{default_variant})

Usage:
    from scl._bindings._loader import lib_f64_i64 as lib
    from scl._bindings import algebra  # Import to register functions
    
    # Functions are pre-bound, direct call with zero overhead
    result = lib.scl_algebra_spmv(A, x, x_size, y, y_size, alpha, beta)
"""

from __future__ import annotations

import ctypes
import inspect
import os
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import (
    Optional, Dict, List, Any, Callable, Union, 
    get_type_hints, get_origin, get_args,
)
import threading

from ._types import (
    Real, Index, Size, Error, Bool, Char,
    Int8, Int16, Int32, Int64,
    UInt8, UInt16, UInt32, UInt64,
    Float, Double, Void,
    SparseHandle, DenseHandle,
    Ptr, ConstPtr, CString, MutableCString,
    _PtrType,
)

# =============================================================================
# Variant Information
# =============================================================================

@dataclass(frozen=True)
class VariantInfo:
    """Information about a library variant."""
    suffix: str
    real_type: str
    index_type: str
    ctypes_real: type
    ctypes_index: type


VARIANTS: Dict[str, VariantInfo] = {{
{variants_dict}
}}

DEFAULT_VARIANT = "{default_variant}"

# =============================================================================
# Type Resolution (Compile-time per variant)
# =============================================================================

def _build_type_map(variant_info: VariantInfo) -> Dict[type, Any]:
    """Build type marker to ctypes mapping for a variant."""
    return {{
        # Dynamic types (variant-dependent)
        Real: variant_info.ctypes_real,
        Index: variant_info.ctypes_index,
        
        # Fixed types
        Size: ctypes.c_size_t,
        Error: ctypes.c_int32,
        Bool: ctypes.c_int,
        Char: ctypes.c_char,
        
        Int8: ctypes.c_int8,
        Int16: ctypes.c_int16,
        Int32: ctypes.c_int32,
        Int64: ctypes.c_int64,
        
        UInt8: ctypes.c_uint8,
        UInt16: ctypes.c_uint16,
        UInt32: ctypes.c_uint32,
        UInt64: ctypes.c_uint64,
        
        Float: ctypes.c_float,
        Double: ctypes.c_double,
        Void: None,
        
        # Handle types
        SparseHandle: ctypes.c_void_p,
        DenseHandle: ctypes.c_void_p,
        
        # String types
        CString: ctypes.c_char_p,
        MutableCString: ctypes.POINTER(ctypes.c_char),
        
        # Python builtins (for convenience)
        int: ctypes.c_int64,
        float: ctypes.c_double,
        bool: ctypes.c_bool,
        None: None,
        type(None): None,
    }}


def _resolve_type(hint: Any, type_map: Dict[type, Any]) -> Any:
    """Resolve a type hint to a ctypes type."""
    # Handle None
    if hint is None or hint is type(None):
        return None
    
    # Handle Ptr[T] and ConstPtr[T]
    if isinstance(hint, _PtrType):
        inner = _resolve_type(hint.pointee, type_map)
        if inner is None:
            return ctypes.c_void_p
        return ctypes.POINTER(inner)
    
    # Handle direct type markers
    if hint in type_map:
        return type_map[hint]
    
    # Handle typing generics (Optional, etc.)
    origin = get_origin(hint)
    if origin is Union:
        args = get_args(hint)
        # Optional[T] is Union[T, None]
        non_none = [a for a in args if a is not type(None)]
        if len(non_none) == 1:
            return _resolve_type(non_none[0], type_map)
    
    # Fallback to void pointer for unknown types
    return ctypes.c_void_p


# =============================================================================
# Function Registry
# =============================================================================

@dataclass
class FunctionSpec:
    """Specification for a registered function."""
    name: str
    func: Callable  # The decorated function (for signature inspection)
    doc: Optional[str] = None


_FUNCTION_REGISTRY: Dict[str, FunctionSpec] = {{}}
_registry_lock = threading.Lock()


def register(func: Callable) -> Callable:
    """
    Register a function for binding.
    
    Uses the function's type annotations to determine argument and return types.
    The function body is ignored - implementation comes from the native library.
    
    Example:
        @register
        def scl_algebra_spmv(
            A: SparseHandle,
            x: Ptr[Real], x_size: Size,
            y: Ptr[Real], y_size: Size,
            alpha: Real, beta: Real,
        ) -> Error:
            # General SpMV: y = alpha * A * x + beta * y
            ...
    """
    with _registry_lock:
        _FUNCTION_REGISTRY[func.__name__] = FunctionSpec(
            name=func.__name__,
            func=func,
            doc=func.__doc__,
        )
    return func


def get_registered_functions() -> List[str]:
    """Get list of registered function names."""
    return list(_FUNCTION_REGISTRY.keys())


def is_registered(name: str) -> bool:
    """Check if a function is registered."""
    return name in _FUNCTION_REGISTRY


# =============================================================================
# Library Path Discovery
# =============================================================================

def _get_lib_name(suffix: str) -> str:
    """Get platform-specific library name."""
    if sys.platform == "win32":
        return f"scl_{{suffix}}.dll"
    elif sys.platform == "darwin":
        return f"libscl_{{suffix}}.dylib"
    return f"libscl_{{suffix}}.so"


def _find_library(suffix: str) -> Optional[Path]:
    """Find the native library."""
    lib_name = _get_lib_name(suffix)
    search_paths = [
        Path(__file__).parent.parent / "libs",
        Path.cwd(),
    ]
    env_dir = os.environ.get("SCL_LIB_DIR")
    if env_dir:
        search_paths.append(Path(env_dir))
    
    for base in search_paths:
        if base.exists():
            lib_path = base / lib_name
            if lib_path.exists():
                return lib_path
    return None


# =============================================================================
# Library Class - Optimized with Pre-binding
# =============================================================================

class Library:
    """
    Optimized library with pre-bound functions.
    
    All registered functions are bound at instantiation time,
    eliminating runtime type resolution overhead.
    """
    
    __slots__ = ("_variant", "_variant_info", "_native", "_type_map", "_functions")
    
    def __init__(self, variant: str, lazy: bool = True):
        """
        Initialize library for a variant.
        
        Args:
            variant: Variant suffix (e.g., "f64_i64")
            lazy: If True, delay library loading until first function access
        """
        if variant not in VARIANTS:
            raise ValueError(f"Unknown variant '{{variant}}'. Available: {{list(VARIANTS.keys())}}")
        
        self._variant = variant
        self._variant_info = VARIANTS[variant]
        self._type_map = _build_type_map(self._variant_info)
        self._native: Optional[ctypes.CDLL] = None
        self._functions: Dict[str, Callable] = {{}}
        
        if not lazy:
            self._ensure_loaded()
    
    @property
    def variant(self) -> str:
        return self._variant
    
    @property
    def variant_info(self) -> VariantInfo:
        return self._variant_info
    
    @property
    def real_type(self) -> type:
        return self._variant_info.ctypes_real
    
    @property
    def index_type(self) -> type:
        return self._variant_info.ctypes_index
    
    @property
    def is_loaded(self) -> bool:
        return self._native is not None
    
    def _ensure_loaded(self) -> None:
        """Ensure library is loaded and all functions are bound."""
        if self._native is not None:
            return
        
        # Load library
        lib_path = _find_library(self._variant)
        if lib_path is None:
            raise RuntimeError(
                f"Cannot find library '{{_get_lib_name(self._variant)}}'. "
                f"Compile with: make compile-cpp"
            )
        
        try:
            self._native = ctypes.CDLL(str(lib_path))
        except OSError as e:
            raise RuntimeError(f"Failed to load '{{lib_path}}': {{e}}") from e
        
        # Pre-bind all registered functions
        self._bind_all_functions()
    
    def _bind_all_functions(self) -> None:
        """Bind all registered functions."""
        for name, spec in _FUNCTION_REGISTRY.items():
            try:
                self._functions[name] = self._bind_function(spec)
            except Exception as e:
                # Log but continue - function may not exist in this build
                pass
    
    def _bind_function(self, spec: FunctionSpec) -> Callable:
        """Bind a single function from its spec."""
        # Get the native function
        try:
            func = getattr(self._native, spec.name)
        except AttributeError:
            raise AttributeError(f"Function '{{spec.name}}' not in library")
        
        # Get type hints from the decorated function
        hints = get_type_hints(spec.func)
        sig = inspect.signature(spec.func)
        
        # Build argtypes
        argtypes = []
        for param_name in sig.parameters:
            if param_name in hints:
                argtypes.append(_resolve_type(hints[param_name], self._type_map))
            else:
                argtypes.append(ctypes.c_void_p)  # Default
        
        # Build restype
        restype = _resolve_type(hints.get("return"), self._type_map)
        
        # Set function signature
        func.argtypes = argtypes
        func.restype = restype
        
        return func
    
    def __getattr__(self, name: str) -> Callable:
        """Get a bound function."""
        if name.startswith("_"):
            raise AttributeError(f"'Library' has no attribute '{{name}}'")
        
        # Ensure loaded
        if self._native is None:
            self._ensure_loaded()
        
        # Return cached function
        if name in self._functions:
            return self._functions[name]
        
        # Try to bind on-demand (for functions registered after Library creation)
        if name in _FUNCTION_REGISTRY:
            spec = _FUNCTION_REGISTRY[name]
            self._functions[name] = self._bind_function(spec)
            return self._functions[name]
        
        raise AttributeError(
            f"Function '{{name}}' not registered. "
            f"Import the binding module first."
        )
    
    def __repr__(self) -> str:
        status = "loaded" if self.is_loaded else "not loaded"
        return f"<Library '{{self._variant}}' {{status}}>"
    
    def get_config(self) -> dict:
        """Get configuration summary."""
        return {{
            "variant": self._variant,
            "real_type": self._variant_info.real_type,
            "index_type": self._variant_info.index_type,
            "lib_path": str(_find_library(self._variant) or "NOT FOUND"),
            "is_loaded": self.is_loaded,
            "bound_functions": list(self._functions.keys()),
        }}


# =============================================================================
# Pre-defined Library Instances (Lazy)
# =============================================================================

{lib_instances}

# Default library
lib = lib_{default_variant}


# =============================================================================
# Convenience Functions
# =============================================================================

def get_library(variant: str) -> Library:
    """Get or create a library for a variant."""
    name = f"lib_{{variant}}"
    if name in globals():
        return globals()[name]
    return Library(variant)


def get_available_variants() -> List[str]:
    """Get available variant suffixes."""
    return list(VARIANTS.keys())


# =============================================================================
# Exports
# =============================================================================

__all__ = [
    "VariantInfo", "Library",
    "register", "get_registered_functions", "is_registered",
    "VARIANTS", "DEFAULT_VARIANT", "get_available_variants",
{lib_exports}
    "lib", "get_library",
]
'''


# =============================================================================
# .pyi Stub File Template
# =============================================================================

LOADER_PYI_TEMPLATE = '''"""
Type stubs for _loader module.

Auto-generated by: codegen
Generated at: {timestamp}
"""

from typing import List, Dict, Callable, Optional, Any
from ctypes import CDLL, c_void_p
from dataclasses import dataclass

@dataclass(frozen=True)
class VariantInfo:
    suffix: str
    real_type: str
    index_type: str
    ctypes_real: type
    ctypes_index: type

VARIANTS: Dict[str, VariantInfo]
DEFAULT_VARIANT: str

def register(func: Callable) -> Callable: ...
def get_registered_functions() -> List[str]: ...
def is_registered(name: str) -> bool: ...
def get_available_variants() -> List[str]: ...
def get_library(variant: str) -> Library: ...

class Library:
    @property
    def variant(self) -> str: ...
    @property
    def variant_info(self) -> VariantInfo: ...
    @property
    def real_type(self) -> type: ...
    @property
    def index_type(self) -> type: ...
    @property
    def is_loaded(self) -> bool: ...
    def get_config(self) -> dict: ...
    
    # === Bound Functions (populated by imports) ===
{function_stubs}

{lib_instance_stubs}
lib: Library
'''


# =============================================================================
# Generators
# =============================================================================

def _generate_variants_dict(config: CodegenConfig) -> str:
    """Generate VARIANTS dictionary."""
    lines = []
    for v in config.variants.variants:
        ctypes_real = {"float32": "ctypes.c_float", "float64": "ctypes.c_double"}.get(v.real_type, "ctypes.c_double")
        ctypes_index = {"int16": "ctypes.c_int16", "int32": "ctypes.c_int32", "int64": "ctypes.c_int64"}.get(v.index_type, "ctypes.c_int64")
        lines.append(f'    "{v.suffix}": VariantInfo("{v.suffix}", "{v.real_type}", "{v.index_type}", {ctypes_real}, {ctypes_index}),')
    return "\n".join(lines)


def _generate_lib_instances(config: CodegenConfig) -> str:
    """Generate library instances."""
    return "\n".join(f'lib_{v.suffix} = Library("{v.suffix}")' for v in config.variants.variants)


def _generate_lib_exports(config: CodegenConfig) -> str:
    """Generate exports."""
    return "\n".join(f'    "lib_{v.suffix}",' for v in config.variants.variants)


def _generate_lib_instance_stubs(config: CodegenConfig) -> str:
    """Generate library instance stubs for .pyi."""
    return "\n".join(f'lib_{v.suffix}: Library' for v in config.variants.variants)


def _format_function_stubs(stubs: list) -> str:
    """Format function stubs for .pyi file with nice multi-line formatting."""
    if not stubs:
        return "    pass"
    
    # Deduplicate by function name, keeping first occurrence
    seen = {}
    for stub in stubs:
        if stub.name not in seen:
            seen[stub.name] = stub
    
    lines = []
    for name in sorted(seen.keys()):
        stub = seen[name]
        
        # Format based on parameter count
        if len(stub.params) <= 2:
            # Short: single line
            params_str = ", ".join(stub.params)
            lines.append(f"    def {name}(self, {params_str}) -> {stub.return_type}: ...")
        else:
            # Long: multi-line
            lines.append(f"    def {name}(")
            lines.append("        self,")
            for param in stub.params:
                lines.append(f"        {param},")
            lines.append(f"    ) -> {stub.return_type}: ...")
        lines.append("")  # Blank line between functions
    
    return "\n".join(lines)


def generate_types_module(config: CodegenConfig, verbose: bool = False) -> bool:
    """Generate _types.py module."""
    output_path = config.python_output_abs / "_types.py"
    
    if output_path.exists() and not config.generation.overwrite:
        if verbose:
            print(f"  Skipping _types.py (exists)")
        return False
    
    content = TYPES_TEMPLATE.format(
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    )
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)
    
    if verbose:
        print(f"  Generated: {output_path}")
    return True


def generate_loader_module(config: CodegenConfig, verbose: bool = False) -> bool:
    """Generate _loader.py module."""
    output_path = config.python_output_abs / "_loader.py"
    
    if output_path.exists() and not config.generation.overwrite:
        if verbose:
            print(f"  Skipping _loader.py (exists)")
        return False
    
    content = LOADER_TEMPLATE.format(
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        variant_list=", ".join(config.variants.variant_suffixes),
        default_variant=config.variants.default_variant,
        variants_dict=_generate_variants_dict(config),
        lib_instances=_generate_lib_instances(config),
        lib_exports=_generate_lib_exports(config),
    )
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)
    
    if verbose:
        print(f"  Generated: {output_path}")
    return True


def generate_loader_pyi(config: CodegenConfig, function_stubs: str, verbose: bool = False) -> bool:
    """Generate _loader.pyi stub file."""
    output_path = config.python_output_abs / "_loader.pyi"
    
    if output_path.exists() and not config.generation.overwrite:
        if verbose:
            print(f"  Skipping _loader.pyi (exists)")
        return False
    
    content = LOADER_PYI_TEMPLATE.format(
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        function_stubs=function_stubs,
        lib_instance_stubs=_generate_lib_instance_stubs(config),
    )
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)
    
    if verbose:
        print(f"  Generated: {output_path}")
    return True


def generate_init_files(config: CodegenConfig, verbose: bool = False) -> int:
    """Generate __init__.py files for all binding directories."""
    output_dir = config.python_output_abs
    generated = 0
    
    # Collect all directories with .py files
    dirs_with_modules: dict[Path, list[str]] = {}
    
    for py_file in output_dir.rglob("*.py"):
        if py_file.name.startswith("_"):
            continue  # Skip private modules
        parent = py_file.parent
        module_name = py_file.stem
        if parent not in dirs_with_modules:
            dirs_with_modules[parent] = []
        dirs_with_modules[parent].append(module_name)
    
    # Also collect subdirectories
    subdirs: dict[Path, list[str]] = {}
    for dir_path in dirs_with_modules:
        parent = dir_path.parent
        if parent != dir_path and parent >= output_dir:
            if parent not in subdirs:
                subdirs[parent] = []
            subdirs[parent].append(dir_path.name)
    
    # Generate __init__.py for each directory
    for dir_path in sorted(set(dirs_with_modules.keys()) | set(subdirs.keys())):
        init_path = dir_path / "__init__.py"
        
        modules = sorted(dirs_with_modules.get(dir_path, []))
        subpackages = sorted(subdirs.get(dir_path, []))
        
        # Calculate relative depth for imports
        try:
            rel = dir_path.relative_to(output_dir)
            depth = len(rel.parts)
        except ValueError:
            depth = 0
        
        prefix = "." * (depth + 1) if depth > 0 else "."
        
        lines = [
            '"""',
            f"Auto-generated __init__.py for {dir_path.name}",
            "",
            "Imports all binding modules to register functions with the library.",
            '"""',
            "",
        ]
        
        # Import subpackages
        if subpackages:
            lines.append("# Subpackages")
            for sub in subpackages:
                lines.append(f"from . import {sub}")
            lines.append("")
        
        # Import modules (to trigger registration)
        if modules:
            lines.append("# Modules (import to register functions)")
            for mod in modules:
                lines.append(f"from . import {mod}")
            lines.append("")
        
        # For root, also export loader components
        if dir_path == output_dir:
            lines.extend([
                "# Loader exports",
                "from ._loader import (",
                "    Library,",
                "    lib,",
            ])
            for v in config.variants.variants:
                lines.append(f"    lib_{v.suffix},")
            lines.extend([
                "    get_library,",
                "    get_available_variants,",
                "    get_registered_functions,",
                ")",
                "",
            ])
        
        # __all__
        all_exports = modules + subpackages
        if dir_path == output_dir:
            all_exports.extend(["lib", "Library", "get_library", "get_available_variants"])
            for v in config.variants.variants:
                all_exports.append(f"lib_{v.suffix}")
        
        lines.append("__all__ = [")
        for name in sorted(set(all_exports)):
            lines.append(f'    "{name}",')
        lines.append("]")
        
        content = "\n".join(lines)
        
        if init_path.exists() and not config.generation.overwrite:
            if verbose:
                print(f"  Skipping {init_path} (exists)")
            continue
        
        init_path.write_text(content)
        generated += 1
        
        if verbose:
            print(f"  Generated: {init_path}")
    
    return generated


def find_headers(
    c_api_dir: Path,
    pattern: str = "*.h",
    exclude_dirs: Optional[set[str]] = None,
) -> list[Path]:
    """Find header files."""
    if exclude_dirs is None:
        exclude_dirs = {"__pycache__", ".git"}
    
    headers = []
    for path in c_api_dir.rglob(pattern):
        if any(excl in path.parts for excl in exclude_dirs):
            continue
        headers.append(path)
    return sorted(headers)


def generate_python_bindings(
    config: CodegenConfig,
    input_path: Optional[Path] = None,
    verbose: bool = False,
) -> int:
    """Generate Python bindings."""
    # Generate support modules
    if verbose:
        print("Generating support modules...")
    
    types_generated = generate_types_module(config, verbose)
    loader_generated = generate_loader_module(config, verbose)
    
    # Find and parse headers
    headers = find_headers(input_path or config.c_api_dir_abs)
    if not headers:
        print("No header files found.")
        return 1
    
    if verbose:
        print(f"Found {len(headers)} header files")
    
    parser = ClangParser(include_dirs=[config.project_root])
    generator = PythonBindingGenerator(config)
    
    success_count = 0
    error_count = 0
    all_function_stubs = []
    
    for header in headers:
        try:
            if verbose:
                print(f"Parsing: {header}")
            
            parsed = parser.parse(header)
            if not parsed.has_content:
                if verbose:
                    print(f"  Skipping (no content)")
                continue
            
            result = generator.generate(parsed)
            result.path.parent.mkdir(parents=True, exist_ok=True)
            
            if result.path.exists() and not config.generation.overwrite:
                if verbose:
                    print(f"  Skipping (exists): {result.path}")
                continue
            
            result.path.write_text(result.content)
            
            # Collect function stubs for .pyi
            if hasattr(result, 'function_stubs'):
                all_function_stubs.extend(result.function_stubs)
            
            if verbose:
                print(f"  Generated: {result.path}")
            
            success_count += 1
            
        except Exception as e:
            print(f"Error processing {header}: {e}", file=sys.stderr)
            error_count += 1
    
    # Generate _loader.pyi with all function stubs
    function_stubs_str = _format_function_stubs(all_function_stubs)
    pyi_generated = generate_loader_pyi(config, function_stubs_str, verbose)
    
    # Generate __init__.py files for all directories
    init_count = generate_init_files(config, verbose)
    
    # Count generated files
    if types_generated:
        success_count += 1
    if loader_generated:
        success_count += 1
    if pyi_generated:
        success_count += 1
    success_count += init_count
    
    print(f"\nGenerated {success_count} files, {error_count} errors")
    return 0 if error_count == 0 else 1


def generate_c_api_docs(
    config: CodegenConfig,
    input_path: Optional[Path] = None,
    verbose: bool = False,
) -> int:
    """Generate C API documentation."""
    headers = find_headers(input_path or config.c_api_dir_abs)
    if not headers:
        print("No header files found.")
        return 1
    
    if verbose:
        print(f"Found {len(headers)} header files")
    
    parser = ClangParser(include_dirs=[config.project_root])
    generator = CApiDocsGenerator(config)
    
    success_count = 0
    error_count = 0
    
    for header in headers:
        try:
            if verbose:
                print(f"Parsing: {header}")
            
            parsed = parser.parse(header)
            if not parsed.has_content:
                continue
            
            result = generator.generate(parsed)
            result.path.parent.mkdir(parents=True, exist_ok=True)
            
            if result.path.exists() and not config.generation.overwrite:
                continue
            
            result.path.write_text(result.content)
            success_count += 1
            
        except Exception as e:
            print(f"Error: {header}: {e}", file=sys.stderr)
            error_count += 1
    
    print(f"\nGenerated {success_count} files, {error_count} errors")
    return 0 if error_count == 0 else 1


def main(argv: Optional[list[str]] = None) -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(prog="codegen", description="SCL-Core Code Generator")
    parser.add_argument("--config", "-c", type=Path)
    parser.add_argument("--verbose", "-v", action="store_true")
    parser.add_argument("--overwrite", action="store_true")
    
    subparsers = parser.add_subparsers(dest="command", required=True)
    
    py_parser = subparsers.add_parser("python-bindings")
    py_parser.add_argument("--input", "-i", type=Path)
    py_parser.add_argument("--output", "-o", type=Path)
    
    docs_parser = subparsers.add_parser("c-api-docs")
    docs_parser.add_argument("--input", "-i", type=Path)
    docs_parser.add_argument("--output", "-o", type=Path)
    
    subparsers.add_parser("all")
    
    args = parser.parse_args(argv)
    config = CodegenConfig.load(args.config)
    
    if args.overwrite:
        config.generation.overwrite = True
    
    if args.command == "python-bindings":
        return generate_python_bindings(config, getattr(args, "input", None), args.verbose)
    elif args.command == "c-api-docs":
        return generate_c_api_docs(config, getattr(args, "input", None), args.verbose)
    elif args.command == "all":
        r1 = generate_python_bindings(config, verbose=args.verbose)
        r2 = generate_c_api_docs(config, verbose=args.verbose)
        return max(r1, r2)
    
    return 1


if __name__ == "__main__":
    sys.exit(main())
