"""
Auto-generated Python bindings for diffusion

Source: scl/binding/c_api/diffusion.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_diffusion_compute_transition_matrix(struct scl_sparse_matrix * adjacency, int symmetric)
_lib.scl_diffusion_compute_transition_matrix.argtypes = [POINTER(c_void_p), c_int]
_lib.scl_diffusion_compute_transition_matrix.restype = c_int

def scl_diffusion_compute_transition_matrix(adjacency, symmetric):
    """
    Args:
        adjacency: struct scl_sparse_matrix *
        symmetric: int
    
    Returns:
        int
    """
    return _lib.scl_diffusion_compute_transition_matrix(adjacency, symmetric)


# C: int scl_diffusion_diffuse_vector(struct scl_sparse_matrix * transition, scl_real_t * x, int n_nodes, long n_steps)
_lib.scl_diffusion_diffuse_vector.argtypes = [POINTER(c_void_p), POINTER(c_double), c_int, c_long]
_lib.scl_diffusion_diffuse_vector.restype = c_int

def scl_diffusion_diffuse_vector(transition, x, n_nodes, n_steps):
    """
    Args:
        transition: struct scl_sparse_matrix *
        x: scl_real_t *
        n_nodes: int
        n_steps: long
    
    Returns:
        int
    """
    return _lib.scl_diffusion_diffuse_vector(transition, x, n_nodes, n_steps)


# C: int scl_diffusion_diffuse_matrix(struct scl_sparse_matrix * transition, scl_real_t * X, long n_nodes, long n_features, long n_steps)
_lib.scl_diffusion_diffuse_matrix.argtypes = [POINTER(c_void_p), POINTER(c_double), c_long, c_long, c_long]
_lib.scl_diffusion_diffuse_matrix.restype = c_int

def scl_diffusion_diffuse_matrix(transition, X, n_nodes, n_features, n_steps):
    """
    Args:
        transition: struct scl_sparse_matrix *
        X: scl_real_t *
        n_nodes: long
        n_features: long
        n_steps: long
    
    Returns:
        int
    """
    return _lib.scl_diffusion_diffuse_matrix(transition, X, n_nodes, n_features, n_steps)


# C: int scl_diffusion_compute_dpt(struct scl_sparse_matrix * transition, long root_cell, scl_real_t * pseudotime, int n_nodes, long max_iter, double tol)
_lib.scl_diffusion_compute_dpt.argtypes = [POINTER(c_void_p), c_long, POINTER(c_double), c_int, c_long, c_double]
_lib.scl_diffusion_compute_dpt.restype = c_int

def scl_diffusion_compute_dpt(transition, root_cell, pseudotime, n_nodes, max_iter, tol):
    """
    Args:
        transition: struct scl_sparse_matrix *
        root_cell: long
        pseudotime: scl_real_t *
        n_nodes: int
        max_iter: long
        tol: double
    
    Returns:
        int
    """
    return _lib.scl_diffusion_compute_dpt(transition, root_cell, pseudotime, n_nodes, max_iter, tol)


# C: int scl_diffusion_compute_dpt_multi_root(struct scl_sparse_matrix * transition, const scl_index_t * root_cells, int n_roots, scl_real_t * pseudotime, int n_nodes, long max_iter)
_lib.scl_diffusion_compute_dpt_multi_root.argtypes = [POINTER(c_void_p), POINTER(c_int64), c_int, POINTER(c_double), c_int, c_long]
_lib.scl_diffusion_compute_dpt_multi_root.restype = c_int

def scl_diffusion_compute_dpt_multi_root(transition, root_cells, n_roots, pseudotime, n_nodes, max_iter):
    """
    Args:
        transition: struct scl_sparse_matrix *
        root_cells: const scl_index_t *
        n_roots: int
        pseudotime: scl_real_t *
        n_nodes: int
        max_iter: long
    
    Returns:
        int
    """
    return _lib.scl_diffusion_compute_dpt_multi_root(transition, root_cells, n_roots, pseudotime, n_nodes, max_iter)


# C: int scl_diffusion_random_walk_with_restart(struct scl_sparse_matrix * transition, const scl_index_t * seed_nodes, int n_seeds, scl_real_t * scores, int n_nodes, double alpha, long max_iter, double tol)
_lib.scl_diffusion_random_walk_with_restart.argtypes = [POINTER(c_void_p), POINTER(c_int64), c_int, POINTER(c_double), c_int, c_double, c_long, c_double]
_lib.scl_diffusion_random_walk_with_restart.restype = c_int

def scl_diffusion_random_walk_with_restart(transition, seed_nodes, n_seeds, scores, n_nodes, alpha, max_iter, tol):
    """
    Args:
        transition: struct scl_sparse_matrix *
        seed_nodes: const scl_index_t *
        n_seeds: int
        scores: scl_real_t *
        n_nodes: int
        alpha: double
        max_iter: long
        tol: double
    
    Returns:
        int
    """
    return _lib.scl_diffusion_random_walk_with_restart(transition, seed_nodes, n_seeds, scores, n_nodes, alpha, max_iter, tol)


# C: int scl_diffusion_personalized_pagerank(struct scl_sparse_matrix * transition, long seed_node, scl_real_t * scores, int n_nodes, double alpha, long max_iter, double tol)
_lib.scl_diffusion_personalized_pagerank.argtypes = [POINTER(c_void_p), c_long, POINTER(c_double), c_int, c_double, c_long, c_double]
_lib.scl_diffusion_personalized_pagerank.restype = c_int

def scl_diffusion_personalized_pagerank(transition, seed_node, scores, n_nodes, alpha, max_iter, tol):
    """
    Args:
        transition: struct scl_sparse_matrix *
        seed_node: long
        scores: scl_real_t *
        n_nodes: int
        alpha: double
        max_iter: long
        tol: double
    
    Returns:
        int
    """
    return _lib.scl_diffusion_personalized_pagerank(transition, seed_node, scores, n_nodes, alpha, max_iter, tol)


# C: int scl_diffusion_diffusion_map_embedding(struct scl_sparse_matrix * transition, scl_real_t * embedding, long n_nodes, long n_components, long n_iter)
_lib.scl_diffusion_diffusion_map_embedding.argtypes = [POINTER(c_void_p), POINTER(c_double), c_long, c_long, c_long]
_lib.scl_diffusion_diffusion_map_embedding.restype = c_int

def scl_diffusion_diffusion_map_embedding(transition, embedding, n_nodes, n_components, n_iter):
    """
    Args:
        transition: struct scl_sparse_matrix *
        embedding: scl_real_t *
        n_nodes: long
        n_components: long
        n_iter: long
    
    Returns:
        int
    """
    return _lib.scl_diffusion_diffusion_map_embedding(transition, embedding, n_nodes, n_components, n_iter)


# C: int scl_diffusion_heat_kernel_signature(struct scl_sparse_matrix * transition, scl_real_t * signature, int n_nodes, double t, long n_steps)
_lib.scl_diffusion_heat_kernel_signature.argtypes = [POINTER(c_void_p), POINTER(c_double), c_int, c_double, c_long]
_lib.scl_diffusion_heat_kernel_signature.restype = c_int

def scl_diffusion_heat_kernel_signature(transition, signature, n_nodes, t, n_steps):
    """
    Args:
        transition: struct scl_sparse_matrix *
        signature: scl_real_t *
        n_nodes: int
        t: double
        n_steps: long
    
    Returns:
        int
    """
    return _lib.scl_diffusion_heat_kernel_signature(transition, signature, n_nodes, t, n_steps)


# C: int scl_diffusion_magic_impute(struct scl_sparse_matrix * transition, scl_real_t * X, long n_nodes, long n_features, long t)
_lib.scl_diffusion_magic_impute.argtypes = [POINTER(c_void_p), POINTER(c_double), c_long, c_long, c_long]
_lib.scl_diffusion_magic_impute.restype = c_int

def scl_diffusion_magic_impute(transition, X, n_nodes, n_features, t):
    """
    Args:
        transition: struct scl_sparse_matrix *
        X: scl_real_t *
        n_nodes: long
        n_features: long
        t: long
    
    Returns:
        int
    """
    return _lib.scl_diffusion_magic_impute(transition, X, n_nodes, n_features, t)


# C: int scl_diffusion_diffusion_distance(struct scl_sparse_matrix * transition, scl_real_t * distances, int n_nodes, long n_steps)
_lib.scl_diffusion_diffusion_distance.argtypes = [POINTER(c_void_p), POINTER(c_double), c_int, c_long]
_lib.scl_diffusion_diffusion_distance.restype = c_int

def scl_diffusion_diffusion_distance(transition, distances, n_nodes, n_steps):
    """
    Args:
        transition: struct scl_sparse_matrix *
        distances: scl_real_t *
        n_nodes: int
        n_steps: long
    
    Returns:
        int
    """
    return _lib.scl_diffusion_diffusion_distance(transition, distances, n_nodes, n_steps)


# C: int scl_diffusion_lazy_random_walk(struct scl_sparse_matrix * transition, scl_real_t * x, int n_nodes, long n_steps, double laziness)
_lib.scl_diffusion_lazy_random_walk.argtypes = [POINTER(c_void_p), POINTER(c_double), c_int, c_long, c_double]
_lib.scl_diffusion_lazy_random_walk.restype = c_int

def scl_diffusion_lazy_random_walk(transition, x, n_nodes, n_steps, laziness):
    """
    Args:
        transition: struct scl_sparse_matrix *
        x: scl_real_t *
        n_nodes: int
        n_steps: long
        laziness: double
    
    Returns:
        int
    """
    return _lib.scl_diffusion_lazy_random_walk(transition, x, n_nodes, n_steps, laziness)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_diffusion_compute_dpt",
    "scl_diffusion_compute_dpt_multi_root",
    "scl_diffusion_compute_transition_matrix",
    "scl_diffusion_diffuse_matrix",
    "scl_diffusion_diffuse_vector",
    "scl_diffusion_diffusion_distance",
    "scl_diffusion_diffusion_map_embedding",
    "scl_diffusion_heat_kernel_signature",
    "scl_diffusion_lazy_random_walk",
    "scl_diffusion_magic_impute",
    "scl_diffusion_personalized_pagerank",
    "scl_diffusion_random_walk_with_restart",
]