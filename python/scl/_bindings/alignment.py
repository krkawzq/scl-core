"""
Auto-generated Python bindings for alignment

Source: scl/binding/c_api/alignment.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_alignment_mnn_pairs(struct scl_sparse_matrix * data1, struct scl_sparse_matrix * data2, long k, scl_index_t * mnn_cell1, scl_index_t * mnn_cell2, scl_size_t * n_pairs)
_lib.scl_alignment_mnn_pairs.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_alignment_mnn_pairs.restype = c_int

def scl_alignment_mnn_pairs(data1, data2, k, mnn_cell1, mnn_cell2, n_pairs):
    """
     @brief Find mutual nearest neighbor pairs between two datasets
 @param[in] data1 First dataset (non-null)
 @param[in] data2 Second dataset (non-null)
 @param[in] k Number of nearest neighbors
 @param[out] mnn_cell1 Cell indices from data1 (non-null, caller-allocated)
 @param[out] mnn_cell2 Cell indices from data2 (non-null, caller-allocated)
 @param[out] n_pairs Number of MNN pairs found (non-null)
 @return SCL_OK on success, error code otherwise
 @note Caller must pre-allocate arrays with sufficient size
    
    Args:
        data1: struct scl_sparse_matrix *
        data2: struct scl_sparse_matrix *
        k: long
        mnn_cell1: scl_index_t *
        mnn_cell2: scl_index_t *
        n_pairs: scl_size_t *
    
    Returns:
        int
    """
    return _lib.scl_alignment_mnn_pairs(data1, data2, k, mnn_cell1, mnn_cell2, n_pairs)


# C: int scl_alignment_find_anchors(struct scl_sparse_matrix * data1, struct scl_sparse_matrix * data2, long k, scl_index_t * anchor_cell1, scl_index_t * anchor_cell2, scl_real_t * anchor_scores, scl_size_t * n_anchors)
_lib.scl_alignment_find_anchors.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_alignment_find_anchors.restype = c_int

def scl_alignment_find_anchors(data1, data2, k, anchor_cell1, anchor_cell2, anchor_scores, n_anchors):
    """
     @brief Find integration anchors between datasets
 @param[in] data1 First dataset (non-null)
 @param[in] data2 Second dataset (non-null)
 @param[in] k Number of nearest neighbors for anchor scoring
 @param[out] anchor_cell1 Anchor cell indices from data1 (non-null)
 @param[out] anchor_cell2 Anchor cell indices from data2 (non-null)
 @param[out] anchor_scores Anchor quality scores (non-null)
 @param[out] n_anchors Number of anchors found (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        data1: struct scl_sparse_matrix *
        data2: struct scl_sparse_matrix *
        k: long
        anchor_cell1: scl_index_t *
        anchor_cell2: scl_index_t *
        anchor_scores: scl_real_t *
        n_anchors: scl_size_t *
    
    Returns:
        int
    """
    return _lib.scl_alignment_find_anchors(data1, data2, k, anchor_cell1, anchor_cell2, anchor_scores, n_anchors)


# C: int scl_alignment_transfer_labels(const scl_index_t * anchor_cell1, const scl_index_t * anchor_cell2, const scl_real_t * anchor_weights, int n_anchors, const scl_index_t * source_labels, int n_source, int n_target, scl_index_t * target_labels, scl_real_t * transfer_confidence)
_lib.scl_alignment_transfer_labels.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, c_int, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_alignment_transfer_labels.restype = c_int

def scl_alignment_transfer_labels(anchor_cell1, anchor_cell2, anchor_weights, n_anchors, source_labels, n_source, n_target, target_labels, transfer_confidence):
    """
     @brief Transfer labels from source to target via anchors
 @param[in] anchor_cell1 Source cell indices [n_anchors] (non-null)
 @param[in] anchor_cell2 Target cell indices [n_anchors] (non-null)
 @param[in] anchor_weights Anchor weights [n_anchors] (non-null)
 @param[in] n_anchors Number of anchors
 @param[in] source_labels Source labels [n_source] (non-null)
 @param[in] n_source Number of source cells
 @param[in] n_target Number of target cells
 @param[out] target_labels Output labels [n_target] (non-null)
 @param[out] transfer_confidence Confidence scores [n_target] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        anchor_cell1: const scl_index_t *
        anchor_cell2: const scl_index_t *
        anchor_weights: const scl_real_t *
        n_anchors: int
        source_labels: const scl_index_t *
        n_source: int
        n_target: int
        target_labels: scl_index_t *
        transfer_confidence: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_alignment_transfer_labels(anchor_cell1, anchor_cell2, anchor_weights, n_anchors, source_labels, n_source, n_target, target_labels, transfer_confidence)


# C: int scl_alignment_integration_score(struct scl_sparse_matrix * integrated_data, const scl_index_t * batch_labels, int n_cells, struct scl_sparse_matrix * neighbors, scl_real_t * score)
_lib.scl_alignment_integration_score.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_alignment_integration_score.restype = c_int

def scl_alignment_integration_score(integrated_data, batch_labels, n_cells, neighbors, score):
    """
     @brief Compute integration quality score (entropy-based)
 @param[in] integrated_data Integrated expression data (non-null)
 @param[in] batch_labels Batch assignment [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] neighbors KNN graph on integrated space (non-null)
 @param[out] score Integration quality score [0, 1] (non-null)
 @return SCL_OK on success, error code otherwise
 @note Higher score = better mixing across batches
    
    Args:
        integrated_data: struct scl_sparse_matrix *
        batch_labels: const scl_index_t *
        n_cells: int
        neighbors: struct scl_sparse_matrix *
        score: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_alignment_integration_score(integrated_data, batch_labels, n_cells, neighbors, score)


# C: int scl_alignment_batch_mixing(const scl_index_t * batch_labels, int n_cells, struct scl_sparse_matrix * neighbors, scl_real_t * mixing_scores)
_lib.scl_alignment_batch_mixing.argtypes = [POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_alignment_batch_mixing.restype = c_int

def scl_alignment_batch_mixing(batch_labels, n_cells, neighbors, mixing_scores):
    """
     @brief Compute batch mixing scores per cell
 @param[in] batch_labels Batch assignment [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] neighbors KNN graph (non-null)
 @param[out] mixing_scores Mixing scores [n_cells] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        batch_labels: const scl_index_t *
        n_cells: int
        neighbors: struct scl_sparse_matrix *
        mixing_scores: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_alignment_batch_mixing(batch_labels, n_cells, neighbors, mixing_scores)


# C: int scl_alignment_kbet_score(struct scl_sparse_matrix * neighbors, const scl_index_t * batch_labels, int n_cells, scl_real_t * score)
_lib.scl_alignment_kbet_score.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p)]
_lib.scl_alignment_kbet_score.restype = c_int

def scl_alignment_kbet_score(neighbors, batch_labels, n_cells, score):
    """
     @brief Compute kBET score for batch effect testing
 @param[in] neighbors KNN graph (non-null)
 @param[in] batch_labels Batch assignment [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[out] score kBET acceptance rate [0, 1] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        neighbors: struct scl_sparse_matrix *
        batch_labels: const scl_index_t *
        n_cells: int
        score: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_alignment_kbet_score(neighbors, batch_labels, n_cells, score)


# C: int scl_alignment_compute_correction_vectors(struct scl_sparse_matrix * data1, struct scl_sparse_matrix * data2, const scl_index_t * mnn_cell1, const scl_index_t * mnn_cell2, int n_pairs, scl_real_t * correction_vectors, int n_features)
_lib.scl_alignment_compute_correction_vectors.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int]
_lib.scl_alignment_compute_correction_vectors.restype = c_int

def scl_alignment_compute_correction_vectors(data1, data2, mnn_cell1, mnn_cell2, n_pairs, correction_vectors, n_features):
    """
     @brief Compute MNN-based correction vectors
 @param[in] data1 First dataset (non-null)
 @param[in] data2 Second dataset (non-null)
 @param[in] mnn_cell1 MNN indices from data1 [n_pairs] (non-null)
 @param[in] mnn_cell2 MNN indices from data2 [n_pairs] (non-null)
 @param[in] n_pairs Number of MNN pairs
 @param[out] correction_vectors Corrections [n2 * n_features] (non-null)
 @param[in] n_features Number of features
 @return SCL_OK on success, error code otherwise
    
    Args:
        data1: struct scl_sparse_matrix *
        data2: struct scl_sparse_matrix *
        mnn_cell1: const scl_index_t *
        mnn_cell2: const scl_index_t *
        n_pairs: int
        correction_vectors: scl_real_t *
        n_features: int
    
    Returns:
        int
    """
    return _lib.scl_alignment_compute_correction_vectors(data1, data2, mnn_cell1, mnn_cell2, n_pairs, correction_vectors, n_features)


# C: int scl_alignment_smooth_correction_vectors(struct scl_sparse_matrix * data2, scl_real_t * correction_vectors, int n_features, double sigma)
_lib.scl_alignment_smooth_correction_vectors.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_double]
_lib.scl_alignment_smooth_correction_vectors.restype = c_int

def scl_alignment_smooth_correction_vectors(data2, correction_vectors, n_features, sigma):
    """
     @brief Smooth correction vectors using Gaussian kernel
 @param[in] data2 Second dataset (non-null)
 @param[in,out] correction_vectors Corrections [n2 * n_features] (non-null)
 @param[in] n_features Number of features
 @param[in] sigma Gaussian kernel bandwidth
 @return SCL_OK on success, error code otherwise
    
    Args:
        data2: struct scl_sparse_matrix *
        correction_vectors: scl_real_t *
        n_features: int
        sigma: double
    
    Returns:
        int
    """
    return _lib.scl_alignment_smooth_correction_vectors(data2, correction_vectors, n_features, sigma)


# C: int scl_alignment_cca_projection(struct scl_sparse_matrix * data1, struct scl_sparse_matrix * data2, int n_components, scl_real_t * projection1, scl_real_t * projection2)
_lib.scl_alignment_cca_projection.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_alignment_cca_projection.restype = c_int

def scl_alignment_cca_projection(data1, data2, n_components, projection1, projection2):
    """
     @brief Project data onto CCA space for alignment
 @param[in] data1 First modality (non-null)
 @param[in] data2 Second modality (non-null)
 @param[in] n_components Number of CCA components
 @param[out] projection1 Projections [n1 * n_components] (non-null)
 @param[out] projection2 Projections [n2 * n_components] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        data1: struct scl_sparse_matrix *
        data2: struct scl_sparse_matrix *
        n_components: int
        projection1: scl_real_t *
        projection2: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_alignment_cca_projection(data1, data2, n_components, projection1, projection2)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_alignment_batch_mixing",
    "scl_alignment_cca_projection",
    "scl_alignment_compute_correction_vectors",
    "scl_alignment_find_anchors",
    "scl_alignment_integration_score",
    "scl_alignment_kbet_score",
    "scl_alignment_mnn_pairs",
    "scl_alignment_smooth_correction_vectors",
    "scl_alignment_transfer_labels",
]