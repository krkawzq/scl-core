"""
Auto-generated Python bindings for centrality

Source: scl/binding/c_api/centrality.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_centrality_degree(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, int normalize)
_lib.scl_centrality_degree.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_int]
_lib.scl_centrality_degree.restype = c_int

def scl_centrality_degree(adjacency, centrality, n_nodes, normalize):
    """
     @brief Compute degree centrality (number of neighbors)
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] normalize SCL_TRUE to normalize by (n-1)
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        normalize: int
    
    Returns:
        int
    """
    return _lib.scl_centrality_degree(adjacency, centrality, n_nodes, normalize)


# C: int scl_centrality_weighted_degree(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, int normalize)
_lib.scl_centrality_weighted_degree.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_int]
_lib.scl_centrality_weighted_degree.restype = c_int

def scl_centrality_weighted_degree(adjacency, centrality, n_nodes, normalize):
    """
     @brief Compute weighted degree centrality (sum of edge weights)
 @param[in] adjacency Weighted adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] normalize SCL_TRUE to normalize by max weight
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        normalize: int
    
    Returns:
        int
    """
    return _lib.scl_centrality_weighted_degree(adjacency, centrality, n_nodes, normalize)


# C: int scl_centrality_pagerank(struct scl_sparse_matrix * adjacency, scl_real_t * scores, int n_nodes, double damping, long max_iter, double tolerance)
_lib.scl_centrality_pagerank.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_double, c_long, c_double]
_lib.scl_centrality_pagerank.restype = c_int

def scl_centrality_pagerank(adjacency, scores, n_nodes, damping, max_iter, tolerance):
    """
     @brief Compute PageRank centrality
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] scores PageRank scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] damping Damping factor [0, 1] (typical: 0.85)
 @param[in] max_iter Maximum iterations
 @param[in] tolerance Convergence tolerance
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        scores: scl_real_t *
        n_nodes: int
        damping: double
        max_iter: long
        tolerance: double
    
    Returns:
        int
    """
    return _lib.scl_centrality_pagerank(adjacency, scores, n_nodes, damping, max_iter, tolerance)


# C: int scl_centrality_personalized_pagerank(struct scl_sparse_matrix * adjacency, const scl_index_t * seed_nodes, int n_seeds, scl_real_t * scores, int n_nodes, double damping, long max_iter, double tolerance)
_lib.scl_centrality_personalized_pagerank.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, c_double, c_long, c_double]
_lib.scl_centrality_personalized_pagerank.restype = c_int

def scl_centrality_personalized_pagerank(adjacency, seed_nodes, n_seeds, scores, n_nodes, damping, max_iter, tolerance):
    """
     @brief Compute personalized PageRank from seed nodes
 @param[in] adjacency Adjacency matrix (non-null)
 @param[in] seed_nodes Seed node indices [n_seeds] (non-null)
 @param[in] n_seeds Number of seed nodes
 @param[out] scores PageRank scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] damping Damping factor
 @param[in] max_iter Maximum iterations
 @param[in] tolerance Convergence tolerance
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        seed_nodes: const scl_index_t *
        n_seeds: int
        scores: scl_real_t *
        n_nodes: int
        damping: double
        max_iter: long
        tolerance: double
    
    Returns:
        int
    """
    return _lib.scl_centrality_personalized_pagerank(adjacency, seed_nodes, n_seeds, scores, n_nodes, damping, max_iter, tolerance)


# C: int scl_centrality_hits(struct scl_sparse_matrix * adjacency, scl_real_t * hub_scores, scl_real_t * authority_scores, int n_nodes, long max_iter, double tolerance)
_lib.scl_centrality_hits.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_int, c_long, c_double]
_lib.scl_centrality_hits.restype = c_int

def scl_centrality_hits(adjacency, hub_scores, authority_scores, n_nodes, max_iter, tolerance):
    """
     @brief Compute HITS hub and authority scores
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] hub_scores Hub scores [n_nodes] (non-null)
 @param[out] authority_scores Authority scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] max_iter Maximum iterations
 @param[in] tolerance Convergence tolerance
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        hub_scores: scl_real_t *
        authority_scores: scl_real_t *
        n_nodes: int
        max_iter: long
        tolerance: double
    
    Returns:
        int
    """
    return _lib.scl_centrality_hits(adjacency, hub_scores, authority_scores, n_nodes, max_iter, tolerance)


# C: int scl_centrality_eigenvector(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, long max_iter, double tolerance)
_lib.scl_centrality_eigenvector.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_long, c_double]
_lib.scl_centrality_eigenvector.restype = c_int

def scl_centrality_eigenvector(adjacency, centrality, n_nodes, max_iter, tolerance):
    """
     @brief Compute eigenvector centrality (principal eigenvector)
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] max_iter Maximum iterations
 @param[in] tolerance Convergence tolerance
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        max_iter: long
        tolerance: double
    
    Returns:
        int
    """
    return _lib.scl_centrality_eigenvector(adjacency, centrality, n_nodes, max_iter, tolerance)


# C: int scl_centrality_katz(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, double alpha, double beta, long max_iter, double tolerance)
_lib.scl_centrality_katz.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_double, c_double, c_long, c_double]
_lib.scl_centrality_katz.restype = c_int

def scl_centrality_katz(adjacency, centrality, n_nodes, alpha, beta, max_iter, tolerance):
    """
     @brief Compute Katz centrality (weighted path count)
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] alpha Attenuation factor (typical: 0.1)
 @param[in] beta Base score (typical: 1.0)
 @param[in] max_iter Maximum iterations
 @param[in] tolerance Convergence tolerance
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        alpha: double
        beta: double
        max_iter: long
        tolerance: double
    
    Returns:
        int
    """
    return _lib.scl_centrality_katz(adjacency, centrality, n_nodes, alpha, beta, max_iter, tolerance)


# C: int scl_centrality_closeness(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, int normalize)
_lib.scl_centrality_closeness.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_int]
_lib.scl_centrality_closeness.restype = c_int

def scl_centrality_closeness(adjacency, centrality, n_nodes, normalize):
    """
     @brief Compute closeness centrality (inverse average distance)
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] normalize SCL_TRUE to normalize
 @return SCL_OK on success, error code otherwise
 @note Requires BFS from each node: O(n * (n + m))
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        normalize: int
    
    Returns:
        int
    """
    return _lib.scl_centrality_closeness(adjacency, centrality, n_nodes, normalize)


# C: int scl_centrality_betweenness(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, int normalize)
_lib.scl_centrality_betweenness.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_int]
_lib.scl_centrality_betweenness.restype = c_int

def scl_centrality_betweenness(adjacency, centrality, n_nodes, normalize):
    """
     @brief Compute betweenness centrality (Brandes algorithm)
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] normalize SCL_TRUE to normalize
 @return SCL_OK on success, error code otherwise
 @note Exact algorithm: O(n * (n + m))
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        normalize: int
    
    Returns:
        int
    """
    return _lib.scl_centrality_betweenness(adjacency, centrality, n_nodes, normalize)


# C: int scl_centrality_betweenness_sampled(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, long n_samples, int normalize, unsigned long seed)
_lib.scl_centrality_betweenness_sampled.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_long, c_int, c_ulong]
_lib.scl_centrality_betweenness_sampled.restype = c_int

def scl_centrality_betweenness_sampled(adjacency, centrality, n_nodes, n_samples, normalize, seed):
    """
     @brief Compute approximate betweenness via sampling
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] n_samples Number of source nodes to sample
 @param[in] normalize SCL_TRUE to normalize
 @param[in] seed Random seed
 @return SCL_OK on success, error code otherwise
 @note Faster approximation: O(n_samples * (n + m))
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        n_samples: long
        normalize: int
        seed: unsigned long
    
    Returns:
        int
    """
    return _lib.scl_centrality_betweenness_sampled(adjacency, centrality, n_nodes, n_samples, normalize, seed)


# C: int scl_centrality_harmonic(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, int normalize)
_lib.scl_centrality_harmonic.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_int]
_lib.scl_centrality_harmonic.restype = c_int

def scl_centrality_harmonic(adjacency, centrality, n_nodes, normalize):
    """
     @brief Compute harmonic centrality (sum of inverse distances)
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] normalize SCL_TRUE to normalize
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        normalize: int
    
    Returns:
        int
    """
    return _lib.scl_centrality_harmonic(adjacency, centrality, n_nodes, normalize)


# C: int scl_centrality_current_flow_approx(struct scl_sparse_matrix * adjacency, scl_real_t * centrality, int n_nodes, long n_walks, long walk_length, unsigned long seed)
_lib.scl_centrality_current_flow_approx.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_long, c_long, c_ulong]
_lib.scl_centrality_current_flow_approx.restype = c_int

def scl_centrality_current_flow_approx(adjacency, centrality, n_nodes, n_walks, walk_length, seed):
    """
     @brief Approximate current flow betweenness via random walks
 @param[in] adjacency Adjacency matrix (non-null)
 @param[out] centrality Centrality scores [n_nodes] (non-null)
 @param[in] n_nodes Number of nodes
 @param[in] n_walks Number of random walks
 @param[in] walk_length Length of each walk
 @param[in] seed Random seed
 @return SCL_OK on success, error code otherwise
    
    Args:
        adjacency: struct scl_sparse_matrix *
        centrality: scl_real_t *
        n_nodes: int
        n_walks: long
        walk_length: long
        seed: unsigned long
    
    Returns:
        int
    """
    return _lib.scl_centrality_current_flow_approx(adjacency, centrality, n_nodes, n_walks, walk_length, seed)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_centrality_betweenness",
    "scl_centrality_betweenness_sampled",
    "scl_centrality_closeness",
    "scl_centrality_current_flow_approx",
    "scl_centrality_degree",
    "scl_centrality_eigenvector",
    "scl_centrality_harmonic",
    "scl_centrality_hits",
    "scl_centrality_katz",
    "scl_centrality_pagerank",
    "scl_centrality_personalized_pagerank",
    "scl_centrality_weighted_degree",
]