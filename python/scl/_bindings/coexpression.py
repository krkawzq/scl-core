"""
Auto-generated Python bindings for coexpression

Source: scl/binding/c_api/coexpression.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Enums
# ===========================================================================

""" @brief Correlation method for co-expression analysis"""

class scl_coexpr_correlation_t:
    """C enum: scl_coexpr_correlation_t"""
    SCL_COEXPR_PEARSON = 0
    SCL_COEXPR_SPEARMAN = 1
    SCL_COEXPR_BICOR = 2

""" @brief Correlation method for co-expression analysis"""

class scl_coexpr_correlation_t:
    """C enum: scl_coexpr_correlation_t"""
    SCL_COEXPR_PEARSON = 0
    SCL_COEXPR_SPEARMAN = 1
    SCL_COEXPR_BICOR = 2

""" @brief Adjacency transformation type"""

class scl_coexpr_adjacency_t:
    """C enum: scl_coexpr_adjacency_t"""
    SCL_COEXPR_UNSIGNED = 0
    SCL_COEXPR_SIGNED = 1
    SCL_COEXPR_SIGNED_HYBRID = 2

""" @brief Adjacency transformation type"""

class scl_coexpr_adjacency_t:
    """C enum: scl_coexpr_adjacency_t"""
    SCL_COEXPR_UNSIGNED = 0
    SCL_COEXPR_SIGNED = 1
    SCL_COEXPR_SIGNED_HYBRID = 2

# ===========================================================================
# Type Aliases
# ===========================================================================

scl_coexpr_correlation_t = c_void_p  # typedef enum scl_coexpr_correlation_t

scl_coexpr_adjacency_t = c_void_p  # typedef enum scl_coexpr_adjacency_t


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_coexpr_correlation_matrix(struct scl_sparse_matrix * expression, long n_cells, long n_genes, scl_real_t * corr_matrix, scl_coexpr_correlation_t corr_type)
_lib.scl_coexpr_correlation_matrix.argtypes = [POINTER(c_void_p), c_long, c_long, POINTER(c_void_p), c_void_p]
_lib.scl_coexpr_correlation_matrix.restype = c_int

def scl_coexpr_correlation_matrix(expression, n_cells, n_genes, corr_matrix, corr_type):
    """
     @brief Compute gene-gene correlation matrix
 @param[in] expression Expression matrix (cells x genes) (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[out] corr_matrix Correlation matrix [n_genes * n_genes] (non-null)
 @param[in] corr_type Correlation method
 @return SCL_OK on success, error code otherwise
 @note Output is symmetric with 1.0 on diagonal
 @note Parallelized over gene pairs
    
    Args:
        expression: struct scl_sparse_matrix *
        n_cells: long
        n_genes: long
        corr_matrix: scl_real_t *
        corr_type: scl_coexpr_correlation_t
    
    Returns:
        int
    """
    return _lib.scl_coexpr_correlation_matrix(expression, n_cells, n_genes, corr_matrix, corr_type)


# C: int scl_coexpr_wgcna_adjacency(struct scl_sparse_matrix * expression, long n_cells, long n_genes, double power, scl_real_t * adjacency, scl_coexpr_correlation_t corr_type, scl_coexpr_adjacency_t adj_type)
_lib.scl_coexpr_wgcna_adjacency.argtypes = [POINTER(c_void_p), c_long, c_long, c_double, POINTER(c_void_p), c_void_p, c_void_p]
_lib.scl_coexpr_wgcna_adjacency.restype = c_int

def scl_coexpr_wgcna_adjacency(expression, n_cells, n_genes, power, adjacency, corr_type, adj_type):
    """
     @brief Compute WGCNA weighted adjacency matrix
 @param[in] expression Expression matrix (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[in] power Soft threshold power
 @param[out] adjacency Adjacency matrix [n_genes * n_genes] (non-null)
 @param[in] corr_type Correlation method
 @param[in] adj_type Adjacency transformation
 @return SCL_OK on success, error code otherwise
    
    Args:
        expression: struct scl_sparse_matrix *
        n_cells: long
        n_genes: long
        power: double
        adjacency: scl_real_t *
        corr_type: scl_coexpr_correlation_t
        adj_type: scl_coexpr_adjacency_t
    
    Returns:
        int
    """
    return _lib.scl_coexpr_wgcna_adjacency(expression, n_cells, n_genes, power, adjacency, corr_type, adj_type)


# C: int scl_coexpr_topological_overlap(const scl_real_t * adjacency, long n_genes, scl_real_t * tom)
_lib.scl_coexpr_topological_overlap.argtypes = [POINTER(c_void_p), c_long, POINTER(c_void_p)]
_lib.scl_coexpr_topological_overlap.restype = c_int

def scl_coexpr_topological_overlap(adjacency, n_genes, tom):
    """
     @brief Compute topological overlap matrix from adjacency
 @param[in] adjacency Adjacency matrix [n_genes * n_genes] (non-null)
 @param[in] n_genes Number of genes
 @param[out] tom TOM [n_genes * n_genes] (non-null)
 @return SCL_OK on success, error code otherwise
 @note TOM measures shared neighbors between genes
    
    Args:
        adjacency: const scl_real_t *
        n_genes: long
        tom: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_coexpr_topological_overlap(adjacency, n_genes, tom)


# C: int scl_coexpr_tom_dissimilarity(const scl_real_t * tom, long n_genes, scl_real_t * dissim)
_lib.scl_coexpr_tom_dissimilarity.argtypes = [POINTER(c_void_p), c_long, POINTER(c_void_p)]
_lib.scl_coexpr_tom_dissimilarity.restype = c_int

def scl_coexpr_tom_dissimilarity(tom, n_genes, dissim):
    """
     @brief Convert TOM to dissimilarity (1 - TOM)
 @param[in] tom TOM [n_genes * n_genes] (non-null)
 @param[in] n_genes Number of genes
 @param[out] dissim Dissimilarity matrix [n_genes * n_genes] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        tom: const scl_real_t *
        n_genes: long
        dissim: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_coexpr_tom_dissimilarity(tom, n_genes, dissim)


# C: int scl_coexpr_detect_modules(const scl_real_t * dissim, long n_genes, scl_index_t * module_labels, scl_index_t * n_modules, long min_module_size, double merge_cut_height)
_lib.scl_coexpr_detect_modules.argtypes = [POINTER(c_void_p), c_long, POINTER(c_void_p), POINTER(c_void_p), c_long, c_double]
_lib.scl_coexpr_detect_modules.restype = c_int

def scl_coexpr_detect_modules(dissim, n_genes, module_labels, n_modules, min_module_size, merge_cut_height):
    """
     @brief Detect co-expression modules via hierarchical clustering
 @param[in] dissim Dissimilarity matrix [n_genes * n_genes] (non-null)
 @param[in] n_genes Number of genes
 @param[out] module_labels Module assignments [n_genes] (non-null)
 @param[out] n_modules Number of modules detected (non-null)
 @param[in] min_module_size Minimum genes per module (typical: 20-30)
 @param[in] merge_cut_height Height to cut dendrogram (typical: 0.25)
 @return SCL_OK on success, error code otherwise
 @note Module 0 = unassigned (too small)
    
    Args:
        dissim: const scl_real_t *
        n_genes: long
        module_labels: scl_index_t *
        n_modules: scl_index_t *
        min_module_size: long
        merge_cut_height: double
    
    Returns:
        int
    """
    return _lib.scl_coexpr_detect_modules(dissim, n_genes, module_labels, n_modules, min_module_size, merge_cut_height)


# C: int scl_coexpr_module_eigengene(struct scl_sparse_matrix * expression, const scl_index_t * module_labels, long module_id, long n_cells, long n_genes, scl_real_t * eigengene)
_lib.scl_coexpr_module_eigengene.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p)]
_lib.scl_coexpr_module_eigengene.restype = c_int

def scl_coexpr_module_eigengene(expression, module_labels, module_id, n_cells, n_genes, eigengene):
    """
     @brief Compute module eigengene (first PC of module genes)
 @param[in] expression Expression matrix (non-null)
 @param[in] module_labels Module assignments [n_genes] (non-null)
 @param[in] module_id Module ID to compute eigengene for
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[out] eigengene Module eigengene [n_cells] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        expression: struct scl_sparse_matrix *
        module_labels: const scl_index_t *
        module_id: long
        n_cells: long
        n_genes: long
        eigengene: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_coexpr_module_eigengene(expression, module_labels, module_id, n_cells, n_genes, eigengene)


# C: int scl_coexpr_all_eigengenes(struct scl_sparse_matrix * expression, const scl_index_t * module_labels, long n_modules, long n_cells, long n_genes, scl_real_t * eigengenes)
_lib.scl_coexpr_all_eigengenes.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p)]
_lib.scl_coexpr_all_eigengenes.restype = c_int

def scl_coexpr_all_eigengenes(expression, module_labels, n_modules, n_cells, n_genes, eigengenes):
    """
     @brief Compute all module eigengenes
 @param[in] expression Expression matrix (non-null)
 @param[in] module_labels Module assignments [n_genes] (non-null)
 @param[in] n_modules Number of modules
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[out] eigengenes Eigengenes [n_cells * n_modules] (non-null)
 @return SCL_OK on success, error code otherwise
 @note Output: eigengenes[cell * n_modules + module]
    
    Args:
        expression: struct scl_sparse_matrix *
        module_labels: const scl_index_t *
        n_modules: long
        n_cells: long
        n_genes: long
        eigengenes: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_coexpr_all_eigengenes(expression, module_labels, n_modules, n_cells, n_genes, eigengenes)


# C: int scl_coexpr_module_trait_correlation(const scl_real_t * eigengenes, const scl_real_t * traits, long n_samples, long n_modules, long n_traits, scl_real_t * correlations, scl_real_t * p_values)
_lib.scl_coexpr_module_trait_correlation.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_coexpr_module_trait_correlation.restype = c_int

def scl_coexpr_module_trait_correlation(eigengenes, traits, n_samples, n_modules, n_traits, correlations, p_values):
    """
     @brief Correlate module eigengenes with sample traits
 @param[in] eigengenes Module eigengenes [n_samples * n_modules] (non-null)
 @param[in] traits Sample traits [n_samples * n_traits] (non-null)
 @param[in] n_samples Number of samples
 @param[in] n_modules Number of modules
 @param[in] n_traits Number of traits
 @param[out] correlations Correlations [n_modules * n_traits] (non-null)
 @param[out] p_values P-values [n_modules * n_traits] (nullable)
 @return SCL_OK on success, error code otherwise
    
    Args:
        eigengenes: const scl_real_t *
        traits: const scl_real_t *
        n_samples: long
        n_modules: long
        n_traits: long
        correlations: scl_real_t *
        p_values: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_coexpr_module_trait_correlation(eigengenes, traits, n_samples, n_modules, n_traits, correlations, p_values)


# C: int scl_coexpr_identify_hub_genes(const scl_real_t * adjacency, const scl_index_t * module_labels, long module_id, long n_genes, scl_index_t * hub_genes, scl_real_t * hub_scores, scl_index_t * n_hubs, long max_hubs)
_lib.scl_coexpr_identify_hub_genes.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_long]
_lib.scl_coexpr_identify_hub_genes.restype = c_int

def scl_coexpr_identify_hub_genes(adjacency, module_labels, module_id, n_genes, hub_genes, hub_scores, n_hubs, max_hubs):
    """
     @brief Identify hub genes (highest intramodular connectivity)
 @param[in] adjacency Adjacency matrix [n_genes * n_genes] (non-null)
 @param[in] module_labels Module assignments [n_genes] (non-null)
 @param[in] module_id Module to find hubs for
 @param[in] n_genes Number of genes
 @param[out] hub_genes Hub gene indices [max_hubs] (non-null)
 @param[out] hub_scores Hub kME scores [max_hubs] (non-null)
 @param[out] n_hubs Number of hub genes found (non-null)
 @param[in] max_hubs Maximum hub genes to return
 @return SCL_OK on success, error code otherwise
 @note Hub genes have highest average connection within module
    
    Args:
        adjacency: const scl_real_t *
        module_labels: const scl_index_t *
        module_id: long
        n_genes: long
        hub_genes: scl_index_t *
        hub_scores: scl_real_t *
        n_hubs: scl_index_t *
        max_hubs: long
    
    Returns:
        int
    """
    return _lib.scl_coexpr_identify_hub_genes(adjacency, module_labels, module_id, n_genes, hub_genes, hub_scores, n_hubs, max_hubs)


# C: int scl_coexpr_gene_module_membership(struct scl_sparse_matrix * expression, const scl_real_t * eigengenes, long n_cells, long n_genes, long n_modules, scl_real_t * kme_matrix)
_lib.scl_coexpr_gene_module_membership.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p)]
_lib.scl_coexpr_gene_module_membership.restype = c_int

def scl_coexpr_gene_module_membership(expression, eigengenes, n_cells, n_genes, n_modules, kme_matrix):
    """
     @brief Compute gene-module membership (correlation with eigengenes)
 @param[in] expression Expression matrix (non-null)
 @param[in] eigengenes Module eigengenes [n_cells * n_modules] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[in] n_modules Number of modules
 @param[out] kme_matrix kME matrix [n_genes * n_modules] (non-null)
 @return SCL_OK on success, error code otherwise
 @note kME[gene, module] = correlation of gene with module eigengene
    
    Args:
        expression: struct scl_sparse_matrix *
        eigengenes: const scl_real_t *
        n_cells: long
        n_genes: long
        n_modules: long
        kme_matrix: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_coexpr_gene_module_membership(expression, eigengenes, n_cells, n_genes, n_modules, kme_matrix)


# C: int scl_coexpr_pick_soft_threshold(struct scl_sparse_matrix * expression, long n_cells, long n_genes, const scl_real_t * powers_to_test, long n_powers, scl_real_t * scale_free_fits, scl_real_t * mean_connectivity, scl_real_t * best_power, scl_coexpr_correlation_t corr_type)
_lib.scl_coexpr_pick_soft_threshold.argtypes = [POINTER(c_void_p), c_long, c_long, POINTER(c_void_p), c_long, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_void_p]
_lib.scl_coexpr_pick_soft_threshold.restype = c_int

def scl_coexpr_pick_soft_threshold(expression, n_cells, n_genes, powers_to_test, n_powers, scale_free_fits, mean_connectivity, best_power, corr_type):
    """
     @brief Pick optimal soft threshold power
 @param[in] expression Expression matrix (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[in] powers_to_test Array of powers to test [n_powers] (non-null)
 @param[in] n_powers Number of powers to test
 @param[out] scale_free_fits R² values for scale-free fit [n_powers] (non-null)
 @param[out] mean_connectivity Mean connectivity [n_powers] (non-null)
 @param[out] best_power Recommended power (non-null)
 @param[in] corr_type Correlation method
 @return SCL_OK on success, error code otherwise
 @note Choose power where R² > 0.8 (scale-free topology)
    
    Args:
        expression: struct scl_sparse_matrix *
        n_cells: long
        n_genes: long
        powers_to_test: const scl_real_t *
        n_powers: long
        scale_free_fits: scl_real_t *
        mean_connectivity: scl_real_t *
        best_power: scl_real_t *
        corr_type: scl_coexpr_correlation_t
    
    Returns:
        int
    """
    return _lib.scl_coexpr_pick_soft_threshold(expression, n_cells, n_genes, powers_to_test, n_powers, scale_free_fits, mean_connectivity, best_power, corr_type)


# C: int scl_coexpr_blockwise_modules(struct scl_sparse_matrix * expression, long n_cells, long n_genes, long block_size, double power, long min_module_size, scl_index_t * module_labels, scl_index_t * n_modules, scl_coexpr_correlation_t corr_type)
_lib.scl_coexpr_blockwise_modules.argtypes = [POINTER(c_void_p), c_long, c_long, c_long, c_double, c_long, POINTER(c_void_p), POINTER(c_void_p), c_void_p]
_lib.scl_coexpr_blockwise_modules.restype = c_int

def scl_coexpr_blockwise_modules(expression, n_cells, n_genes, block_size, power, min_module_size, module_labels, n_modules, corr_type):
    """
     @brief Detect modules in large networks via blockwise processing
 @param[in] expression Expression matrix (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[in] block_size Genes per block (typical: 5000)
 @param[in] power Soft threshold power
 @param[in] min_module_size Minimum genes per module
 @param[out] module_labels Module assignments [n_genes] (non-null)
 @param[out] n_modules Number of modules detected (non-null)
 @param[in] corr_type Correlation method
 @return SCL_OK on success, error code otherwise
 @note Use for n_genes > 10000 to reduce memory usage
    
    Args:
        expression: struct scl_sparse_matrix *
        n_cells: long
        n_genes: long
        block_size: long
        power: double
        min_module_size: long
        module_labels: scl_index_t *
        n_modules: scl_index_t *
        corr_type: scl_coexpr_correlation_t
    
    Returns:
        int
    """
    return _lib.scl_coexpr_blockwise_modules(expression, n_cells, n_genes, block_size, power, min_module_size, module_labels, n_modules, corr_type)


# C: int scl_coexpr_module_preservation(const scl_real_t * adjacency_ref, const scl_real_t * adjacency_test, const scl_index_t * module_labels, long n_genes, long n_modules, scl_real_t * zsummary)
_lib.scl_coexpr_module_preservation.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, POINTER(c_void_p)]
_lib.scl_coexpr_module_preservation.restype = c_int

def scl_coexpr_module_preservation(adjacency_ref, adjacency_test, module_labels, n_genes, n_modules, zsummary):
    """
     @brief Assess module preservation between datasets
 @param[in] adjacency_ref Reference adjacency [n_genes * n_genes] (non-null)
 @param[in] adjacency_test Test adjacency [n_genes * n_genes] (non-null)
 @param[in] module_labels Module assignments [n_genes] (non-null)
 @param[in] n_genes Number of genes
 @param[in] n_modules Number of modules
 @param[out] zsummary Z-summary scores [n_modules] (non-null)
 @return SCL_OK on success, error code otherwise
 @note Z > 2: weak preservation, Z > 10: strong preservation
    
    Args:
        adjacency_ref: const scl_real_t *
        adjacency_test: const scl_real_t *
        module_labels: const scl_index_t *
        n_genes: long
        n_modules: long
        zsummary: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_coexpr_module_preservation(adjacency_ref, adjacency_test, module_labels, n_genes, n_modules, zsummary)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_coexpr_adjacency_t",
    "scl_coexpr_adjacency_t",
    "scl_coexpr_adjacency_t",
    "scl_coexpr_all_eigengenes",
    "scl_coexpr_blockwise_modules",
    "scl_coexpr_correlation_matrix",
    "scl_coexpr_correlation_t",
    "scl_coexpr_correlation_t",
    "scl_coexpr_correlation_t",
    "scl_coexpr_detect_modules",
    "scl_coexpr_gene_module_membership",
    "scl_coexpr_identify_hub_genes",
    "scl_coexpr_module_eigengene",
    "scl_coexpr_module_preservation",
    "scl_coexpr_module_trait_correlation",
    "scl_coexpr_pick_soft_threshold",
    "scl_coexpr_tom_dissimilarity",
    "scl_coexpr_topological_overlap",
    "scl_coexpr_wgcna_adjacency",
]