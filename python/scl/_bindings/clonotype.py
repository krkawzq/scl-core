"""
Auto-generated Python bindings for clonotype

Source: scl/binding/c_api/clonotype.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_clonotype_size_distribution(const scl_index_t * clone_ids, int n_cells, scl_size_t * clone_sizes, scl_size_t * n_clones, int max_clones)
_lib.scl_clonotype_size_distribution.argtypes = [POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_clonotype_size_distribution.restype = c_int

def scl_clonotype_size_distribution(clone_ids, n_cells, clone_sizes, n_clones, max_clones):
    """
     @brief Compute size distribution of clones
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[out] clone_sizes Size of each clone [max_clones] (non-null)
 @param[out] n_clones Number of non-empty clones (non-null)
 @param[in] max_clones Maximum possible clone ID + 1
 @return SCL_OK on success, error code otherwise
    
    Args:
        clone_ids: const scl_index_t *
        n_cells: int
        clone_sizes: scl_size_t *
        n_clones: scl_size_t *
        max_clones: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_size_distribution(clone_ids, n_cells, clone_sizes, n_clones, max_clones)


# C: int scl_clonotype_diversity(const scl_index_t * clone_ids, int n_cells, scl_real_t * shannon_diversity, scl_real_t * simpson_diversity, scl_real_t * gini_index)
_lib.scl_clonotype_diversity.argtypes = [POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_clonotype_diversity.restype = c_int

def scl_clonotype_diversity(clone_ids, n_cells, shannon_diversity, simpson_diversity, gini_index):
    """
     @brief Compute clonal diversity indices
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[out] shannon_diversity Shannon entropy (non-null)
 @param[out] simpson_diversity Simpson diversity index (non-null)
 @param[out] gini_index Gini coefficient (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        clone_ids: const scl_index_t *
        n_cells: int
        shannon_diversity: scl_real_t *
        simpson_diversity: scl_real_t *
        gini_index: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_clonotype_diversity(clone_ids, n_cells, shannon_diversity, simpson_diversity, gini_index)


# C: int scl_clonotype_dynamics(const scl_index_t * clone_ids_t1, int n_cells_t1, const scl_index_t * clone_ids_t2, int n_cells_t2, scl_real_t * expansion_rates, scl_size_t * n_clones, int max_clones)
_lib.scl_clonotype_dynamics.argtypes = [POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_clonotype_dynamics.restype = c_int

def scl_clonotype_dynamics(clone_ids_t1, n_cells_t1, clone_ids_t2, n_cells_t2, expansion_rates, n_clones, max_clones):
    """
     @brief Compute clone expansion rates between timepoints
 @param[in] clone_ids_t1 Clone IDs at timepoint 1 [n_cells_t1] (non-null)
 @param[in] n_cells_t1 Number of cells at timepoint 1
 @param[in] clone_ids_t2 Clone IDs at timepoint 2 [n_cells_t2] (non-null)
 @param[in] n_cells_t2 Number of cells at timepoint 2
 @param[out] expansion_rates Log2 fold change [n_clones] (non-null)
 @param[out] n_clones Number of clones tracked (non-null)
 @param[in] max_clones Maximum clones to track
 @return SCL_OK on success, error code otherwise
 @note expansion_rate = log2((size_t2 + 1) / (size_t1 + 1))
    
    Args:
        clone_ids_t1: const scl_index_t *
        n_cells_t1: int
        clone_ids_t2: const scl_index_t *
        n_cells_t2: int
        expansion_rates: scl_real_t *
        n_clones: scl_size_t *
        max_clones: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_dynamics(clone_ids_t1, n_cells_t1, clone_ids_t2, n_cells_t2, expansion_rates, n_clones, max_clones)


# C: int scl_clonotype_shared(const scl_index_t * clone_ids_sample1, int n_cells_1, const scl_index_t * clone_ids_sample2, int n_cells_2, scl_index_t * shared_clones, scl_size_t * n_shared, scl_real_t * jaccard_index, int max_shared)
_lib.scl_clonotype_shared.argtypes = [POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_clonotype_shared.restype = c_int

def scl_clonotype_shared(clone_ids_sample1, n_cells_1, clone_ids_sample2, n_cells_2, shared_clones, n_shared, jaccard_index, max_shared):
    """
     @brief Find shared clonotypes between two samples
 @param[in] clone_ids_sample1 Clone IDs from sample 1 [n_cells_1] (non-null)
 @param[in] n_cells_1 Number of cells in sample 1
 @param[in] clone_ids_sample2 Clone IDs from sample 2 [n_cells_2] (non-null)
 @param[in] n_cells_2 Number of cells in sample 2
 @param[out] shared_clones Shared clone IDs [max_shared] (non-null)
 @param[out] n_shared Number of shared clones (non-null)
 @param[out] jaccard_index Jaccard similarity [0, 1] (non-null)
 @param[in] max_shared Maximum shared clones to return
 @return SCL_OK on success, error code otherwise
    
    Args:
        clone_ids_sample1: const scl_index_t *
        n_cells_1: int
        clone_ids_sample2: const scl_index_t *
        n_cells_2: int
        shared_clones: scl_index_t *
        n_shared: scl_size_t *
        jaccard_index: scl_real_t *
        max_shared: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_shared(clone_ids_sample1, n_cells_1, clone_ids_sample2, n_cells_2, shared_clones, n_shared, jaccard_index, max_shared)


# C: int scl_clonotype_phenotype(struct scl_sparse_matrix * expression, const scl_index_t * clone_ids, int n_cells, int n_genes, scl_real_t * clone_profiles, scl_size_t * n_clones, int max_clones)
_lib.scl_clonotype_phenotype.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_int, POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_clonotype_phenotype.restype = c_int

def scl_clonotype_phenotype(expression, clone_ids, n_cells, n_genes, clone_profiles, n_clones, max_clones):
    """
     @brief Compute mean expression profile per clone
 @param[in] expression Expression matrix (cells x genes) (non-null)
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[out] clone_profiles Mean expression [n_clones * n_genes] (non-null)
 @param[out] n_clones Number of clones found (non-null)
 @param[in] max_clones Maximum clones to process
 @return SCL_OK on success, error code otherwise
    
    Args:
        expression: struct scl_sparse_matrix *
        clone_ids: const scl_index_t *
        n_cells: int
        n_genes: int
        clone_profiles: scl_real_t *
        n_clones: scl_size_t *
        max_clones: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_phenotype(expression, clone_ids, n_cells, n_genes, clone_profiles, n_clones, max_clones)


# C: int scl_clonotype_clonality_score(const scl_index_t * clone_ids, const scl_index_t * cluster_labels, int n_cells, scl_real_t * clonality_per_cluster, int n_clusters)
_lib.scl_clonotype_clonality_score.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int]
_lib.scl_clonotype_clonality_score.restype = c_int

def scl_clonotype_clonality_score(clone_ids, cluster_labels, n_cells, clonality_per_cluster, n_clusters):
    """
     @brief Compute clonality score for each cluster
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] cluster_labels Cluster assignments [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[out] clonality_per_cluster Clonality scores [n_clusters] (non-null)
 @param[in] n_clusters Number of clusters
 @return SCL_OK on success, error code otherwise
 @note Clonality = 1 - normalized_entropy (higher = more clonal)
    
    Args:
        clone_ids: const scl_index_t *
        cluster_labels: const scl_index_t *
        n_cells: int
        clonality_per_cluster: scl_real_t *
        n_clusters: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_clonality_score(clone_ids, cluster_labels, n_cells, clonality_per_cluster, n_clusters)


# C: int scl_clonotype_repertoire_overlap(const scl_index_t * clone_ids_1, int n_cells_1, const scl_index_t * clone_ids_2, int n_cells_2, scl_real_t * overlap_index)
_lib.scl_clonotype_repertoire_overlap.argtypes = [POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, POINTER(c_void_p)]
_lib.scl_clonotype_repertoire_overlap.restype = c_int

def scl_clonotype_repertoire_overlap(clone_ids_1, n_cells_1, clone_ids_2, n_cells_2, overlap_index):
    """
     @brief Compute Morisita-Horn overlap index between repertoires
 @param[in] clone_ids_1 Clone IDs from repertoire 1 [n_cells_1] (non-null)
 @param[in] n_cells_1 Number of cells in repertoire 1
 @param[in] clone_ids_2 Clone IDs from repertoire 2 [n_cells_2] (non-null)
 @param[in] n_cells_2 Number of cells in repertoire 2
 @param[out] overlap_index Morisita-Horn index [0, 1] (non-null)
 @return SCL_OK on success, error code otherwise
 @note Index = 1 means identical repertoires, 0 means no overlap
    
    Args:
        clone_ids_1: const scl_index_t *
        n_cells_1: int
        clone_ids_2: const scl_index_t *
        n_cells_2: int
        overlap_index: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_clonotype_repertoire_overlap(clone_ids_1, n_cells_1, clone_ids_2, n_cells_2, overlap_index)


# C: int scl_clonotype_diversity_per_cluster(const scl_index_t * clone_ids, const scl_index_t * cluster_labels, int n_cells, scl_real_t * shannon_per_cluster, scl_real_t * simpson_per_cluster, int n_clusters)
_lib.scl_clonotype_diversity_per_cluster.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_clonotype_diversity_per_cluster.restype = c_int

def scl_clonotype_diversity_per_cluster(clone_ids, cluster_labels, n_cells, shannon_per_cluster, simpson_per_cluster, n_clusters):
    """
     @brief Compute diversity indices per cluster
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] cluster_labels Cluster assignments [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[out] shannon_per_cluster Shannon diversity [n_clusters] (non-null)
 @param[out] simpson_per_cluster Simpson diversity [n_clusters] (non-null)
 @param[in] n_clusters Number of clusters
 @return SCL_OK on success, error code otherwise
    
    Args:
        clone_ids: const scl_index_t *
        cluster_labels: const scl_index_t *
        n_cells: int
        shannon_per_cluster: scl_real_t *
        simpson_per_cluster: scl_real_t *
        n_clusters: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_diversity_per_cluster(clone_ids, cluster_labels, n_cells, shannon_per_cluster, simpson_per_cluster, n_clusters)


# C: int scl_clonotype_transition_matrix(const scl_index_t * clone_ids, const scl_index_t * cluster_labels, int n_cells, scl_real_t * transition_matrix, int n_clusters)
_lib.scl_clonotype_transition_matrix.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int]
_lib.scl_clonotype_transition_matrix.restype = c_int

def scl_clonotype_transition_matrix(clone_ids, cluster_labels, n_cells, transition_matrix, n_clusters):
    """
     @brief Compute clone transition probabilities between clusters
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] cluster_labels Cluster assignments [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[out] transition_matrix Transition matrix [n_clusters * n_clusters] (non-null)
 @param[in] n_clusters Number of clusters
 @return SCL_OK on success, error code otherwise
 @note transition_matrix[i*n_clusters + j] = P(clone in cluster i appears in cluster j)
    
    Args:
        clone_ids: const scl_index_t *
        cluster_labels: const scl_index_t *
        n_cells: int
        transition_matrix: scl_real_t *
        n_clusters: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_transition_matrix(clone_ids, cluster_labels, n_cells, transition_matrix, n_clusters)


# C: int scl_clonotype_rarefaction(const scl_index_t * clone_ids, int n_cells, int subsample_size, int n_iterations, scl_real_t * mean_diversity, scl_real_t * std_diversity, unsigned long seed)
_lib.scl_clonotype_rarefaction.argtypes = [POINTER(c_void_p), c_int, c_int, c_int, POINTER(c_void_p), POINTER(c_void_p), c_ulong]
_lib.scl_clonotype_rarefaction.restype = c_int

def scl_clonotype_rarefaction(clone_ids, n_cells, subsample_size, n_iterations, mean_diversity, std_diversity, seed):
    """
     @brief Estimate diversity at subsampled sizes (rarefaction curve)
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] subsample_size Subsample size for rarefaction
 @param[in] n_iterations Number of bootstrap iterations
 @param[out] mean_diversity Mean Shannon diversity (non-null)
 @param[out] std_diversity Standard deviation (non-null)
 @param[in] seed Random seed
 @return SCL_OK on success, error code otherwise
    
    Args:
        clone_ids: const scl_index_t *
        n_cells: int
        subsample_size: int
        n_iterations: int
        mean_diversity: scl_real_t *
        std_diversity: scl_real_t *
        seed: unsigned long
    
    Returns:
        int
    """
    return _lib.scl_clonotype_rarefaction(clone_ids, n_cells, subsample_size, n_iterations, mean_diversity, std_diversity, seed)


# C: int scl_clonotype_detect_expanded(const scl_index_t * clone_ids, int n_cells, int expansion_threshold, scl_index_t * expanded_clones, scl_size_t * n_expanded, int max_expanded)
_lib.scl_clonotype_detect_expanded.argtypes = [POINTER(c_void_p), c_int, c_int, POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_clonotype_detect_expanded.restype = c_int

def scl_clonotype_detect_expanded(clone_ids, n_cells, expansion_threshold, expanded_clones, n_expanded, max_expanded):
    """
     @brief Detect expanded clones above size threshold
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] expansion_threshold Minimum size for expansion
 @param[out] expanded_clones Expanded clone IDs [max_expanded] (non-null)
 @param[out] n_expanded Number of expanded clones (non-null)
 @param[in] max_expanded Maximum expanded clones to return
 @return SCL_OK on success, error code otherwise
    
    Args:
        clone_ids: const scl_index_t *
        n_cells: int
        expansion_threshold: int
        expanded_clones: scl_index_t *
        n_expanded: scl_size_t *
        max_expanded: int
    
    Returns:
        int
    """
    return _lib.scl_clonotype_detect_expanded(clone_ids, n_cells, expansion_threshold, expanded_clones, n_expanded, max_expanded)


# C: int scl_clonotype_size_statistics(const scl_index_t * clone_ids, int n_cells, scl_real_t * mean_size, scl_real_t * median_size, scl_real_t * max_size, scl_size_t * n_singletons, scl_size_t * n_clones)
_lib.scl_clonotype_size_statistics.argtypes = [POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_clonotype_size_statistics.restype = c_int

def scl_clonotype_size_statistics(clone_ids, n_cells, mean_size, median_size, max_size, n_singletons, n_clones):
    """
     @brief Compute clone size statistics
 @param[in] clone_ids Clone IDs [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[out] mean_size Mean clone size (non-null)
 @param[out] median_size Median clone size (non-null)
 @param[out] max_size Maximum clone size (non-null)
 @param[out] n_singletons Number of clones with size 1 (non-null)
 @param[out] n_clones Total number of clones (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        clone_ids: const scl_index_t *
        n_cells: int
        mean_size: scl_real_t *
        median_size: scl_real_t *
        max_size: scl_real_t *
        n_singletons: scl_size_t *
        n_clones: scl_size_t *
    
    Returns:
        int
    """
    return _lib.scl_clonotype_size_statistics(clone_ids, n_cells, mean_size, median_size, max_size, n_singletons, n_clones)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_clonotype_clonality_score",
    "scl_clonotype_detect_expanded",
    "scl_clonotype_diversity",
    "scl_clonotype_diversity_per_cluster",
    "scl_clonotype_dynamics",
    "scl_clonotype_phenotype",
    "scl_clonotype_rarefaction",
    "scl_clonotype_repertoire_overlap",
    "scl_clonotype_shared",
    "scl_clonotype_size_distribution",
    "scl_clonotype_size_statistics",
    "scl_clonotype_transition_matrix",
]