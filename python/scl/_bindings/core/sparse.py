"""
Auto-generated Python bindings for sparse

Source: scl/binding/c_api/core/sparse.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Enums
# ===========================================================================

""" @brief Block allocation strategy for sparse matrices"""

class scl_block_strategy_t:
    """C enum: scl_block_strategy_t"""
    SCL_BLOCK_STRATEGY_CONTIGUOUS = 0
    SCL_BLOCK_STRATEGY_SMALL = 1
    SCL_BLOCK_STRATEGY_LARGE = 2
    SCL_BLOCK_STRATEGY_ADAPTIVE = 3

""" @brief Block allocation strategy for sparse matrices"""

class scl_block_strategy_t:
    """C enum: scl_block_strategy_t"""
    SCL_BLOCK_STRATEGY_CONTIGUOUS = 0
    SCL_BLOCK_STRATEGY_SMALL = 1
    SCL_BLOCK_STRATEGY_LARGE = 2
    SCL_BLOCK_STRATEGY_ADAPTIVE = 3

# ===========================================================================
# Structures
# ===========================================================================

class scl_sparse_layout_info_t(Structure):
    """ @brief Memory layout information for sparse matrices"""
    _fields_ = [
        ("data_block_count", c_long),
        ("index_block_count", c_long),
        ("data_bytes", c_int),
        ("index_bytes", c_int),
        ("metadata_bytes", c_int),
        ("is_contiguous", c_int),
        ("is_traditional_format", c_int),
    ]

class scl_sparse_layout_info_t(Structure):
    """ @brief Memory layout information for sparse matrices"""
    _fields_ = [
        ("data_block_count", c_long),
        ("index_block_count", c_long),
        ("data_bytes", c_int),
        ("index_bytes", c_int),
        ("metadata_bytes", c_int),
        ("is_contiguous", c_int),
        ("is_traditional_format", c_int),
    ]

# ===========================================================================
# Type Aliases
# ===========================================================================

scl_block_strategy_t = c_void_p  # typedef enum scl_block_strategy_t

scl_sparse_layout_info_t = c_void_p  # typedef struct scl_sparse_layout_info_t


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_sparse_create(scl_sparse_t * out, long rows, long cols, long nnz, const scl_index_t * indptr, const scl_index_t * indices, const scl_real_t * data, int is_csr)
_lib.scl_sparse_create.argtypes = [POINTER(POINTER(scl_sparse_matrix)), c_long, c_long, c_long, POINTER(c_int64), POINTER(c_int64), POINTER(c_double), c_int]
_lib.scl_sparse_create.restype = c_int

def scl_sparse_create(out, rows, cols, nnz, indptr, indices, data, is_csr):
    """
     @brief Create sparse matrix from traditional CSR/CSC format (deep copy)
 @param[out] out Output matrix handle (non-null)
 @param[in] rows Number of rows (> 0)
 @param[in] cols Number of columns (> 0)
 @param[in] nnz Number of non-zeros (>= 0)
 @param[in] indptr Offset array [rows+1] for CSR or [cols+1] for CSC (non-null)
 @param[in] indices Column (CSR) or row (CSC) indices [nnz] (non-null)
 @param[in] data Non-zero values [nnz] (non-null)
 @param[in] is_csr SCL_TRUE for CSR, SCL_FALSE for CSC
 @return SCL_OK on success, error code otherwise
 @note Copies all data (safe for temporary inputs)
 @note Caller must call scl_sparse_destroy() when done
    
    Args:
        out: scl_sparse_t *
        rows: long
        cols: long
        nnz: long
        indptr: const scl_index_t *
        indices: const scl_index_t *
        data: const scl_real_t *
        is_csr: int
    
    Returns:
        int
    """
    return _lib.scl_sparse_create(out, rows, cols, nnz, indptr, indices, data, is_csr)


# C: int scl_sparse_create_with_strategy(scl_sparse_t * out, long rows, long cols, long nnz, const scl_index_t * indptr, const scl_index_t * indices, const scl_real_t * data, int is_csr, scl_block_strategy_t strategy)
_lib.scl_sparse_create_with_strategy.argtypes = [POINTER(POINTER(scl_sparse_matrix)), c_long, c_long, c_long, POINTER(c_int64), POINTER(c_int64), POINTER(c_double), c_int, c_void_p]
_lib.scl_sparse_create_with_strategy.restype = c_int

def scl_sparse_create_with_strategy(out, rows, cols, nnz, indptr, indices, data, is_csr, strategy):
    """
     @brief Create sparse matrix with specific block strategy
 @param[out] out Output matrix handle (non-null)
 @param[in] rows Number of rows (> 0)
 @param[in] cols Number of columns (> 0)
 @param[in] nnz Number of non-zeros (>= 0)
 @param[in] indptr Offset array (non-null)
 @param[in] indices Index array (non-null)
 @param[in] data Value array (non-null)
 @param[in] is_csr SCL_TRUE for CSR, SCL_FALSE for CSC
 @param[in] strategy Block allocation strategy
 @return SCL_OK on success, error code otherwise
    
    Args:
        out: scl_sparse_t *
        rows: long
        cols: long
        nnz: long
        indptr: const scl_index_t *
        indices: const scl_index_t *
        data: const scl_real_t *
        is_csr: int
        strategy: scl_block_strategy_t
    
    Returns:
        int
    """
    return _lib.scl_sparse_create_with_strategy(out, rows, cols, nnz, indptr, indices, data, is_csr, strategy)


# C: int scl_sparse_wrap(scl_sparse_t * out, long rows, long cols, long nnz, scl_index_t * indptr, scl_index_t * indices, scl_real_t * data, int is_csr)
_lib.scl_sparse_wrap.argtypes = [POINTER(POINTER(scl_sparse_matrix)), c_long, c_long, c_long, POINTER(c_int64), POINTER(c_int64), POINTER(c_double), c_int]
_lib.scl_sparse_wrap.restype = c_int

def scl_sparse_wrap(out, rows, cols, nnz, indptr, indices, data, is_csr):
    """
     @brief Wrap external data as zero-copy view (does not copy)
 @param[out] out Output matrix handle (non-null)
 @param[in] rows Number of rows (> 0)
 @param[in] cols Number of columns (> 0)
 @param[in] nnz Number of non-zeros (>= 0)
 @param[in,out] indptr Mutable offset array (caller manages lifetime)
 @param[in,out] indices Mutable index array (caller manages lifetime)
 @param[in,out] data Mutable value array (caller manages lifetime)
 @param[in] is_csr SCL_TRUE for CSR, SCL_FALSE for CSC
 @return SCL_OK on success, error code otherwise
 @note Does NOT copy data - caller must keep arrays alive
 @note Use scl_sparse_wrap_and_own() to transfer ownership
    
    Args:
        out: scl_sparse_t *
        rows: long
        cols: long
        nnz: long
        indptr: scl_index_t *
        indices: scl_index_t *
        data: scl_real_t *
        is_csr: int
    
    Returns:
        int
    """
    return _lib.scl_sparse_wrap(out, rows, cols, nnz, indptr, indices, data, is_csr)


# C: int scl_sparse_wrap_and_own(scl_sparse_t * out, long rows, long cols, long nnz, scl_index_t * indptr, scl_index_t * indices, scl_real_t * data, int is_csr)
_lib.scl_sparse_wrap_and_own.argtypes = [POINTER(POINTER(scl_sparse_matrix)), c_long, c_long, c_long, POINTER(c_int64), POINTER(c_int64), POINTER(c_double), c_int]
_lib.scl_sparse_wrap_and_own.restype = c_int

def scl_sparse_wrap_and_own(out, rows, cols, nnz, indptr, indices, data, is_csr):
    """
     @brief Wrap and transfer ownership to SCL (for NumPy integration)
 @param[out] out Output matrix handle (non-null)
 @param[in] rows Number of rows (> 0)
 @param[in] cols Number of columns (> 0)
 @param[in] nnz Number of non-zeros (>= 0)
 @param[in,out] indptr Offset array (ownership transferred)
 @param[in,out] indices Index array (ownership transferred)
 @param[in,out] data Value array (ownership transferred)
 @param[in] is_csr SCL_TRUE for CSR, SCL_FALSE for CSC
 @return SCL_OK on success, error code otherwise
 @note SCL takes ownership and will free arrays on destroy
 @note Arrays must be allocated with new[] (will use delete[])
    
    Args:
        out: scl_sparse_t *
        rows: long
        cols: long
        nnz: long
        indptr: scl_index_t *
        indices: scl_index_t *
        data: scl_real_t *
        is_csr: int
    
    Returns:
        int
    """
    return _lib.scl_sparse_wrap_and_own(out, rows, cols, nnz, indptr, indices, data, is_csr)


# C: int scl_sparse_clone(struct scl_sparse_matrix * src, scl_sparse_t * out)
_lib.scl_sparse_clone.argtypes = [POINTER(c_void_p), POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_clone.restype = c_int

def scl_sparse_clone(src, out):
    """
     @brief Clone sparse matrix (deep copy)
 @param[in] src Source matrix (non-null)
 @param[out] out Output matrix (non-null)
 @return SCL_OK on success, error code otherwise
 @note Creates independent copy with separate memory
 @note Preserves block structure of source
    
    Args:
        src: struct scl_sparse_matrix *
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_clone(src, out)


# C: int scl_sparse_destroy(scl_sparse_t * matrix)
_lib.scl_sparse_destroy.argtypes = [POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_destroy.restype = c_int

def scl_sparse_destroy(matrix):
    """
     @brief Destroy sparse matrix and release resources
 @param[in,out] matrix Pointer to matrix handle (may be null)
 @return SCL_OK on success, error code otherwise
 @note Sets *matrix to NULL after destruction
 @note Safe to call with NULL or already-destroyed handle
    
    Args:
        matrix: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_destroy(matrix)


# C: int scl_sparse_rows(struct scl_sparse_matrix * matrix, scl_index_t * out)
_lib.scl_sparse_rows.argtypes = [POINTER(c_void_p), POINTER(c_int64)]
_lib.scl_sparse_rows.restype = c_int

def scl_sparse_rows(matrix, out):
    """
     @brief Get number of rows
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_index_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_rows(matrix, out)


# C: int scl_sparse_cols(struct scl_sparse_matrix * matrix, scl_index_t * out)
_lib.scl_sparse_cols.argtypes = [POINTER(c_void_p), POINTER(c_int64)]
_lib.scl_sparse_cols.restype = c_int

def scl_sparse_cols(matrix, out):
    """
     @brief Get number of columns
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_index_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_cols(matrix, out)


# C: int scl_sparse_nnz(struct scl_sparse_matrix * matrix, scl_index_t * out)
_lib.scl_sparse_nnz.argtypes = [POINTER(c_void_p), POINTER(c_int64)]
_lib.scl_sparse_nnz.restype = c_int

def scl_sparse_nnz(matrix, out):
    """
     @brief Get number of non-zeros
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_index_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_nnz(matrix, out)


# C: int scl_sparse_is_csr(struct scl_sparse_matrix * matrix, scl_bool_t * out)
_lib.scl_sparse_is_csr.argtypes = [POINTER(c_void_p), POINTER(c_int)]
_lib.scl_sparse_is_csr.restype = c_int

def scl_sparse_is_csr(matrix, out):
    """
     @brief Check if matrix is in CSR format
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_bool_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_is_csr(matrix, out)


# C: int scl_sparse_is_csc(struct scl_sparse_matrix * matrix, scl_bool_t * out)
_lib.scl_sparse_is_csc.argtypes = [POINTER(c_void_p), POINTER(c_int)]
_lib.scl_sparse_is_csc.restype = c_int

def scl_sparse_is_csc(matrix, out):
    """
     @brief Check if matrix is in CSC format
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_bool_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_is_csc(matrix, out)


# C: int scl_sparse_is_valid(struct scl_sparse_matrix * matrix, scl_bool_t * out)
_lib.scl_sparse_is_valid.argtypes = [POINTER(c_void_p), POINTER(c_int)]
_lib.scl_sparse_is_valid.restype = c_int

def scl_sparse_is_valid(matrix, out):
    """
     @brief Check if matrix is in valid state
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_bool_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_is_valid(matrix, out)


# C: int scl_sparse_is_contiguous(struct scl_sparse_matrix * matrix, scl_bool_t * out)
_lib.scl_sparse_is_contiguous.argtypes = [POINTER(c_void_p), POINTER(c_int)]
_lib.scl_sparse_is_contiguous.restype = c_int

def scl_sparse_is_contiguous(matrix, out):
    """
     @brief Check if matrix is contiguous (single block)
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_bool_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_is_contiguous(matrix, out)


# C: int scl_sparse_layout_info(struct scl_sparse_matrix * matrix, scl_sparse_layout_info_t * info)
_lib.scl_sparse_layout_info.argtypes = [POINTER(c_void_p), POINTER(scl_sparse_layout_info_t)]
_lib.scl_sparse_layout_info.restype = c_int

def scl_sparse_layout_info(matrix, info):
    """
     @brief Get layout information
    
    Args:
        matrix: struct scl_sparse_matrix *
        info: scl_sparse_layout_info_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_layout_info(matrix, info)


# C: int scl_sparse_export(struct scl_sparse_matrix * matrix, scl_index_t * indptr, scl_index_t * indices, scl_real_t * data)
_lib.scl_sparse_export.argtypes = [POINTER(c_void_p), POINTER(c_int64), POINTER(c_int64), POINTER(c_double)]
_lib.scl_sparse_export.restype = c_int

def scl_sparse_export(matrix, indptr, indices, data):
    """
     @brief Export to traditional CSR/CSC format (copies data)
 @param[in] matrix Matrix handle (non-null)
 @param[out] indptr Caller-allocated offset array [primary_dim+1]
 @param[out] indices Caller-allocated index array [nnz]
 @param[out] data Caller-allocated value array [nnz]
 @return SCL_OK on success, error code otherwise
 @note Caller responsible for allocating arrays
 @note primary_dim = rows (CSR) or cols (CSC)
    
    Args:
        matrix: struct scl_sparse_matrix *
        indptr: scl_index_t *
        indices: scl_index_t *
        data: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_export(matrix, indptr, indices, data)


# C: int scl_sparse_get_lengths(struct scl_sparse_matrix * matrix, const scl_index_t ** lengths, scl_size_t * lengths_size)
_lib.scl_sparse_get_lengths.argtypes = [POINTER(c_void_p), POINTER(POINTER(c_int64)), POINTER(c_int)]
_lib.scl_sparse_get_lengths.restype = c_int

def scl_sparse_get_lengths(matrix, lengths, lengths_size):
    """
     @brief Get read-only pointer to lengths array (zero-copy)
 @param[in] matrix Matrix handle (non-null)
 @param[out] lengths Pointer to internal lengths array (nnz per row/col)
 @param[out] lengths_size Size of lengths array (= rows for CSR, cols for CSC)
 @return SCL_OK on success, error code otherwise
 @note Sparse stores lengths[], not traditional indptr[]. Use scl_sparse_export()
       if you need indptr format.
 @note Pointers valid while matrix alive
    
    Args:
        matrix: struct scl_sparse_matrix *
        lengths: const scl_index_t **
        lengths_size: scl_size_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_get_lengths(matrix, lengths, lengths_size)


# C: int scl_sparse_get_indices(struct scl_sparse_matrix * matrix, const scl_index_t ** indices, scl_size_t * indices_size)
_lib.scl_sparse_get_indices.argtypes = [POINTER(c_void_p), POINTER(POINTER(c_int64)), POINTER(c_int)]
_lib.scl_sparse_get_indices.restype = c_int

def scl_sparse_get_indices(matrix, indices, indices_size):
    """
     @brief Get read-only pointer to index array (zero-copy)
 @param[in] matrix Matrix handle (non-null, must be contiguous)
 @param[out] indices Pointer to internal index array
 @param[out] indices_size Size of index array (= nnz)
 @return SCL_OK on success, error code otherwise
 @note Only valid if matrix is contiguous
 @note Pointers valid while matrix alive
    
    Args:
        matrix: struct scl_sparse_matrix *
        indices: const scl_index_t **
        indices_size: scl_size_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_get_indices(matrix, indices, indices_size)


# C: int scl_sparse_get_data(struct scl_sparse_matrix * matrix, const scl_real_t ** data, scl_size_t * data_size)
_lib.scl_sparse_get_data.argtypes = [POINTER(c_void_p), POINTER(POINTER(c_double)), POINTER(c_int)]
_lib.scl_sparse_get_data.restype = c_int

def scl_sparse_get_data(matrix, data, data_size):
    """
     @brief Get read-only pointer to value array (zero-copy)
 @param[in] matrix Matrix handle (non-null, must be contiguous)
 @param[out] data Pointer to internal value array
 @param[out] data_size Size of value array (= nnz)
 @return SCL_OK on success, error code otherwise
 @note Only valid if matrix is contiguous
 @note Pointers valid while matrix alive
    
    Args:
        matrix: struct scl_sparse_matrix *
        data: const scl_real_t **
        data_size: scl_size_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_get_data(matrix, data, data_size)


# C: int scl_sparse_transpose(struct scl_sparse_matrix * src, scl_sparse_t * out)
_lib.scl_sparse_transpose.argtypes = [POINTER(c_void_p), POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_transpose.restype = c_int

def scl_sparse_transpose(src, out):
    """
     @brief Transpose matrix (CSR <-> CSC)
 @param[in] src Source matrix (non-null)
 @param[out] out Transposed matrix (non-null)
 @return SCL_OK on success, error code otherwise
 @note CSR becomes CSC and vice versa
    
    Args:
        src: struct scl_sparse_matrix *
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_transpose(src, out)


# C: int scl_sparse_to_contiguous(struct scl_sparse_matrix * src, scl_sparse_t * out)
_lib.scl_sparse_to_contiguous.argtypes = [POINTER(c_void_p), POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_to_contiguous.restype = c_int

def scl_sparse_to_contiguous(src, out):
    """
     @brief Convert to contiguous storage (traditional format)
 @param[in] src Source matrix (non-null)
 @param[out] out Contiguous matrix (non-null)
 @return SCL_OK on success, error code otherwise
 @note Result compatible with SciPy/NumPy sparse matrices
    
    Args:
        src: struct scl_sparse_matrix *
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_to_contiguous(src, out)


# C: int scl_sparse_from_coo(scl_sparse_t * out, long rows, long cols, long nnz, const scl_index_t * row_indices, const scl_index_t * col_indices, const scl_real_t * values, int is_csr, scl_block_strategy_t strategy)
_lib.scl_sparse_from_coo.argtypes = [POINTER(POINTER(scl_sparse_matrix)), c_long, c_long, c_long, POINTER(c_int64), POINTER(c_int64), POINTER(c_double), c_int, c_void_p]
_lib.scl_sparse_from_coo.restype = c_int

def scl_sparse_from_coo(out, rows, cols, nnz, row_indices, col_indices, values, is_csr, strategy):
    """
     @brief Create sparse matrix from COO (Coordinate) format
 @param[out] out Output matrix (non-null)
 @param[in] rows Number of rows (> 0)
 @param[in] cols Number of columns (> 0)
 @param[in] nnz Number of non-zeros (>= 0)
 @param[in] row_indices Row indices [nnz]
 @param[in] col_indices Column indices [nnz]
 @param[in] values Values [nnz]
 @param[in] is_csr Output format: SCL_TRUE=CSR, SCL_FALSE=CSC
 @param[in] strategy Block allocation strategy
 @return SCL_OK on success, error code otherwise
 @note COO format: (row[i], col[i], value[i]) tuples
 @note Input may have duplicate entries (will be summed)
    
    Args:
        out: scl_sparse_t *
        rows: long
        cols: long
        nnz: long
        row_indices: const scl_index_t *
        col_indices: const scl_index_t *
        values: const scl_real_t *
        is_csr: int
        strategy: scl_block_strategy_t
    
    Returns:
        int
    """
    return _lib.scl_sparse_from_coo(out, rows, cols, nnz, row_indices, col_indices, values, is_csr, strategy)


# C: int scl_sparse_to_coo(struct scl_sparse_matrix * matrix, scl_index_t ** row_indices, scl_index_t ** col_indices, scl_real_t ** values, scl_index_t * nnz)
_lib.scl_sparse_to_coo.argtypes = [POINTER(c_void_p), POINTER(POINTER(c_int64)), POINTER(POINTER(c_int64)), POINTER(POINTER(c_double)), POINTER(c_int64)]
_lib.scl_sparse_to_coo.restype = c_int

def scl_sparse_to_coo(matrix, row_indices, col_indices, values, nnz):
    """
     @brief Export to COO format (allocates new arrays)
 @param[in] matrix Matrix handle (non-null)
 @param[out] row_indices Row indices array [nnz] (SCL allocates)
 @param[out] col_indices Column indices array [nnz] (SCL allocates)
 @param[out] values Values array [nnz] (SCL allocates)
 @param[out] nnz Number of non-zeros
 @return SCL_OK on success, error code otherwise
 @note SCL allocates arrays - caller must free (implementation-defined)
    
    Args:
        matrix: struct scl_sparse_matrix *
        row_indices: scl_index_t **
        col_indices: scl_index_t **
        values: scl_real_t **
        nnz: scl_index_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_to_coo(matrix, row_indices, col_indices, values, nnz)


# C: int scl_sparse_row_range_view(struct scl_sparse_matrix * src, long start, long end, scl_sparse_t * out)
_lib.scl_sparse_row_range_view.argtypes = [POINTER(c_void_p), c_long, c_long, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_row_range_view.restype = c_int

def scl_sparse_row_range_view(src, start, end, out):
    """
     @brief Row range slice (zero-copy view)
 @param[in] src Source CSR matrix (non-null)
 @param[in] start Start row index [0, rows)
 @param[in] end End row index (start, rows]
 @param[out] out Slice handle (non-null)
 @return SCL_OK on success, error code otherwise
 @note Only for CSR matrices (error for CSC)
 @note Zero-copy: shares data with source
    
    Args:
        src: struct scl_sparse_matrix *
        start: long
        end: long
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_row_range_view(src, start, end, out)


# C: int scl_sparse_row_range_copy(struct scl_sparse_matrix * src, long start, long end, scl_block_strategy_t strategy, scl_sparse_t * out)
_lib.scl_sparse_row_range_copy.argtypes = [POINTER(c_void_p), c_long, c_long, c_void_p, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_row_range_copy.restype = c_int

def scl_sparse_row_range_copy(src, start, end, strategy, out):
    """
     @brief Row range slice with copy
 @param[in] src Source CSR matrix (non-null)
 @param[in] start Start row index
 @param[in] end End row index
 @param[in] strategy Block allocation strategy
 @param[out] out Slice handle (non-null)
 @return SCL_OK on success, error code otherwise
 @note Creates independent copy
    
    Args:
        src: struct scl_sparse_matrix *
        start: long
        end: long
        strategy: scl_block_strategy_t
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_row_range_copy(src, start, end, strategy, out)


# C: int scl_sparse_slice_rows(struct scl_sparse_matrix * src, const scl_index_t * row_indices, int n_rows, scl_sparse_t * out)
_lib.scl_sparse_slice_rows.argtypes = [POINTER(c_void_p), POINTER(c_int64), c_int, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_slice_rows.restype = c_int

def scl_sparse_slice_rows(src, row_indices, n_rows, out):
    """
     @brief Row slice (arbitrary indices, zero-copy if possible)
 @param[in] src Source CSR matrix (non-null)
 @param[in] row_indices Array of row indices to select
 @param[in] n_rows Number of rows to select
 @param[out] out Slice handle (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        src: struct scl_sparse_matrix *
        row_indices: const scl_index_t *
        n_rows: int
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_slice_rows(src, row_indices, n_rows, out)


# C: int scl_sparse_row_slice_copy(struct scl_sparse_matrix * src, const scl_index_t * row_indices, int n_rows, scl_block_strategy_t strategy, scl_sparse_t * out)
_lib.scl_sparse_row_slice_copy.argtypes = [POINTER(c_void_p), POINTER(c_int64), c_int, c_void_p, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_row_slice_copy.restype = c_int

def scl_sparse_row_slice_copy(src, row_indices, n_rows, strategy, out):
    """
     @brief Row slice with copy
    
    Args:
        src: struct scl_sparse_matrix *
        row_indices: const scl_index_t *
        n_rows: int
        strategy: scl_block_strategy_t
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_row_slice_copy(src, row_indices, n_rows, strategy, out)


# C: int scl_sparse_col_slice(struct scl_sparse_matrix * src, const scl_index_t * col_indices, int n_cols, scl_block_strategy_t strategy, scl_sparse_t * out)
_lib.scl_sparse_col_slice.argtypes = [POINTER(c_void_p), POINTER(c_int64), c_int, c_void_p, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_col_slice.restype = c_int

def scl_sparse_col_slice(src, col_indices, n_cols, strategy, out):
    """
     @brief Column slice (arbitrary indices)
 @param[in] src Source matrix (non-null)
 @param[in] col_indices Array of column indices to select
 @param[in] n_cols Number of columns to select
 @param[in] strategy Block allocation strategy
 @param[out] out Slice handle (non-null)
 @return SCL_OK on success, error code otherwise
 @note Efficient for CSC, requires reconstruction for CSR
    
    Args:
        src: struct scl_sparse_matrix *
        col_indices: const scl_index_t *
        n_cols: int
        strategy: scl_block_strategy_t
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_col_slice(src, col_indices, n_cols, strategy, out)


# C: int scl_sparse_slice_cols(struct scl_sparse_matrix * src, const scl_index_t * col_indices, int n_cols, scl_sparse_t * out)
_lib.scl_sparse_slice_cols.argtypes = [POINTER(c_void_p), POINTER(c_int64), c_int, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_slice_cols.restype = c_int

def scl_sparse_slice_cols(src, col_indices, n_cols, out):
    """
     @brief Column slice for CSC matrices (zero-copy)
    
    Args:
        src: struct scl_sparse_matrix *
        col_indices: const scl_index_t *
        n_cols: int
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_slice_cols(src, col_indices, n_cols, out)


# C: int scl_sparse_vstack(const scl_sparse_t * matrices, int n_matrices, scl_block_strategy_t strategy, scl_sparse_t * out)
_lib.scl_sparse_vstack.argtypes = [POINTER(POINTER(scl_sparse_matrix)), c_int, c_void_p, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_vstack.restype = c_int

def scl_sparse_vstack(matrices, n_matrices, strategy, out):
    """
     @brief Vertical stack (concatenate CSR matrices by rows)
 @param[in] matrices Array of CSR matrices (all non-null)
 @param[in] n_matrices Number of matrices (> 0)
 @param[in] strategy Block allocation strategy
 @param[out] out Stacked matrix (non-null)
 @return SCL_OK on success, error code otherwise
 @note All matrices must have same number of columns
 @note All matrices must be CSR format
    
    Args:
        matrices: const scl_sparse_t *
        n_matrices: int
        strategy: scl_block_strategy_t
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_vstack(matrices, n_matrices, strategy, out)


# C: int scl_sparse_hstack(const scl_sparse_t * matrices, int n_matrices, scl_block_strategy_t strategy, scl_sparse_t * out)
_lib.scl_sparse_hstack.argtypes = [POINTER(POINTER(scl_sparse_matrix)), c_int, c_void_p, POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_hstack.restype = c_int

def scl_sparse_hstack(matrices, n_matrices, strategy, out):
    """
     @brief Horizontal stack (concatenate CSC matrices by columns)
 @param[in] matrices Array of CSC matrices (all non-null)
 @param[in] n_matrices Number of matrices (> 0)
 @param[in] strategy Block allocation strategy
 @param[out] out Stacked matrix (non-null)
 @return SCL_OK on success, error code otherwise
 @note All matrices must have same number of rows
 @note All matrices must be CSC format
    
    Args:
        matrices: const scl_sparse_t *
        n_matrices: int
        strategy: scl_block_strategy_t
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_hstack(matrices, n_matrices, strategy, out)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_block_strategy_t",
    "scl_block_strategy_t",
    "scl_block_strategy_t",
    "scl_sparse_clone",
    "scl_sparse_col_slice",
    "scl_sparse_cols",
    "scl_sparse_create",
    "scl_sparse_create_with_strategy",
    "scl_sparse_destroy",
    "scl_sparse_export",
    "scl_sparse_from_coo",
    "scl_sparse_get_data",
    "scl_sparse_get_indices",
    "scl_sparse_get_lengths",
    "scl_sparse_hstack",
    "scl_sparse_is_contiguous",
    "scl_sparse_is_csc",
    "scl_sparse_is_csr",
    "scl_sparse_is_valid",
    "scl_sparse_layout_info",
    "scl_sparse_layout_info_t",
    "scl_sparse_layout_info_t",
    "scl_sparse_layout_info_t",
    "scl_sparse_nnz",
    "scl_sparse_row_range_copy",
    "scl_sparse_row_range_view",
    "scl_sparse_row_slice_copy",
    "scl_sparse_rows",
    "scl_sparse_slice_cols",
    "scl_sparse_slice_rows",
    "scl_sparse_to_contiguous",
    "scl_sparse_to_coo",
    "scl_sparse_transpose",
    "scl_sparse_vstack",
    "scl_sparse_wrap",
    "scl_sparse_wrap_and_own",
]