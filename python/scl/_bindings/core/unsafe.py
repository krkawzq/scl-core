"""
Auto-generated Python bindings for unsafe

Source: scl/binding/c_api/core/unsafe.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Structures
# ===========================================================================

class scl_sparse_raw(Structure):
    """ @brief Raw sparse matrix layout (CSR or CSC)
 @warning ABI UNSTABLE - struct may change without notice
 @details Exposes internal block-allocated sparse matrix structure
 MEMORY LAYOUT:
   - data_ptrs[i] points to values for row i (CSR) or column i (CSC)
   - indices_ptrs[i] points to column (CSR) or row (CSC) indices
   - lengths[i] = number of non-zeros in row/column i
   - For traditional CSR/CSC, use contiguous strategy
 LIFETIME RULES:
   - data_ptrs, indices_ptrs, lengths: managed by registry
   - Individual row/column arrays: may be aliases (shared with views)
   - Caller MUST NOT free any pointers directly
   - Use scl_sparse_destroy() for proper cleanup"""
    _fields_ = [
        ("data_ptrs", POINTER(c_void_p)),
        ("indices_ptrs", POINTER(c_void_p)),
        ("lengths", POINTER(c_int64)),
        ("rows", c_long),
        ("cols", c_long),
        ("nnz", c_long),
        ("is_csr", c_int),
    ]

class scl_sparse_raw(Structure):
    """ @brief Raw sparse matrix layout (CSR or CSC)
 @warning ABI UNSTABLE - struct may change without notice
 @details Exposes internal block-allocated sparse matrix structure
 MEMORY LAYOUT:
   - data_ptrs[i] points to values for row i (CSR) or column i (CSC)
   - indices_ptrs[i] points to column (CSR) or row (CSC) indices
   - lengths[i] = number of non-zeros in row/column i
   - For traditional CSR/CSC, use contiguous strategy
 LIFETIME RULES:
   - data_ptrs, indices_ptrs, lengths: managed by registry
   - Individual row/column arrays: may be aliases (shared with views)
   - Caller MUST NOT free any pointers directly
   - Use scl_sparse_destroy() for proper cleanup"""
    _fields_ = [
        ("data_ptrs", POINTER(c_void_p)),
        ("indices_ptrs", POINTER(c_void_p)),
        ("lengths", POINTER(c_int64)),
        ("rows", c_long),
        ("cols", c_long),
        ("nnz", c_long),
        ("is_csr", c_int),
    ]

class scl_dense_raw(Structure):
    """ @brief Raw dense matrix layout (row-major, pure view)
 @warning ABI UNSTABLE - struct may change without notice
 MEMORY LAYOUT:
   - Row-major: data[i * stride + j] = element at (i, j)
   - For contiguous: stride == cols
   - For views: stride may be > cols (skip padding)
 LIFETIME RULES:
   - DenseView is always a view - never owns data
   - Caller MUST ensure data pointer remains valid
   - Use scl_dense_destroy() to free the handle (not the data)"""
    _fields_ = [
        ("data", POINTER(c_double)),
        ("rows", c_long),
        ("cols", c_long),
        ("stride", c_long),
    ]

class scl_dense_raw(Structure):
    """ @brief Raw dense matrix layout (row-major, pure view)
 @warning ABI UNSTABLE - struct may change without notice
 MEMORY LAYOUT:
   - Row-major: data[i * stride + j] = element at (i, j)
   - For contiguous: stride == cols
   - For views: stride may be > cols (skip padding)
 LIFETIME RULES:
   - DenseView is always a view - never owns data
   - Caller MUST ensure data pointer remains valid
   - Use scl_dense_destroy() to free the handle (not the data)"""
    _fields_ = [
        ("data", POINTER(c_double)),
        ("rows", c_long),
        ("cols", c_long),
        ("stride", c_long),
    ]

# ===========================================================================
# Type Aliases
# ===========================================================================

scl_sparse_raw_t = c_void_p  # typedef struct scl_sparse_raw

scl_dense_raw_t = c_void_p  # typedef struct scl_dense_raw


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_sparse_unsafe_get_raw(struct scl_sparse_matrix * matrix, scl_sparse_raw_t * out)
_lib.scl_sparse_unsafe_get_raw.argtypes = [POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_sparse_unsafe_get_raw.restype = c_int

def scl_sparse_unsafe_get_raw(matrix, out):
    """
     @brief Get raw internal structure (read-only, does not transfer ownership)
 @param[in] matrix Matrix handle (non-null)
 @param[out] out Raw structure (non-null)
 @return SCL_OK on success, error code otherwise
 @warning Pointers in out become invalid when matrix is destroyed
 @warning DO NOT modify pointed-to data (undefined behavior)
 @warning DO NOT free any pointers (use scl_sparse_destroy)
    
    Args:
        matrix: struct scl_sparse_matrix *
        out: scl_sparse_raw_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_unsafe_get_raw(matrix, out)


# C: int scl_sparse_unsafe_from_raw(const scl_sparse_raw_t * raw, scl_sparse_t * out)
_lib.scl_sparse_unsafe_from_raw.argtypes = [POINTER(c_void_p), POINTER(POINTER(scl_sparse_matrix))]
_lib.scl_sparse_unsafe_from_raw.restype = c_int

def scl_sparse_unsafe_from_raw(raw, out):
    """
     @brief Create matrix from raw structure (EXTREMELY DANGEROUS)
 @param[in] raw Raw structure with pre-allocated arrays (non-null)
 @param[out] out Matrix handle (non-null)
 @return SCL_OK on success, error code otherwise
 @warning CALLER MUST register all pointers with registry first
 @warning Incorrect usage WILL cause memory corruption
 @warning For experts only - prefer safe API
 @note This function does NOT register pointers - that's caller's job
    
    Args:
        raw: const scl_sparse_raw_t *
        out: scl_sparse_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_unsafe_from_raw(raw, out)


# C: int scl_dense_unsafe_get_raw(struct scl_dense_matrix * matrix, scl_dense_raw_t * out)
_lib.scl_dense_unsafe_get_raw.argtypes = [POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_dense_unsafe_get_raw.restype = c_int

def scl_dense_unsafe_get_raw(matrix, out):
    """
     @brief Get raw internal structure (read-only, does not transfer ownership)
 @param[in] matrix Matrix handle (non-null)
 @param[out] out Raw structure (non-null)
 @return SCL_OK on success, error code otherwise
 @warning data pointer lifetime managed by caller (DenseView never owns data)
    
    Args:
        matrix: struct scl_dense_matrix *
        out: scl_dense_raw_t *
    
    Returns:
        int
    """
    return _lib.scl_dense_unsafe_get_raw(matrix, out)


# C: int scl_dense_unsafe_from_raw(const scl_dense_raw_t * raw, scl_dense_t * out)
_lib.scl_dense_unsafe_from_raw.argtypes = [POINTER(c_void_p), POINTER(POINTER(scl_dense_matrix))]
_lib.scl_dense_unsafe_from_raw.restype = c_int

def scl_dense_unsafe_from_raw(raw, out):
    """
     @brief Create matrix view from raw structure
 @param[in] raw Raw structure (non-null)
 @param[out] out Matrix handle (non-null)
 @return SCL_OK on success, error code otherwise
 @warning DenseView never owns data - caller manages data lifetime
 @warning data pointer must remain valid for matrix lifetime
    
    Args:
        raw: const scl_dense_raw_t *
        out: scl_dense_t *
    
    Returns:
        int
    """
    return _lib.scl_dense_unsafe_from_raw(raw, out)


# C: int scl_sparse_unsafe_get_row(struct scl_sparse_matrix * matrix, long row, scl_real_t ** data, scl_index_t ** indices, scl_index_t * length)
_lib.scl_sparse_unsafe_get_row.argtypes = [POINTER(c_void_p), c_long, POINTER(POINTER(c_double)), POINTER(POINTER(c_int64)), POINTER(c_int64)]
_lib.scl_sparse_unsafe_get_row.restype = c_int

def scl_sparse_unsafe_get_row(matrix, row, data, indices, length):
    """
     @brief Get row data pointer for CSR matrix (zero-overhead)
 @param[in] matrix CSR matrix handle (non-null, must be CSR)
 @param[in] row Row index [0, rows)
 @param[out] data Row data pointer (non-null)
 @param[out] indices Row indices pointer (non-null)
 @param[out] length Number of non-zeros in row (non-null)
 @return SCL_OK on success, error code otherwise
 @warning NO bounds checking in release builds
 @warning Pointers invalid after matrix destruction
 @warning DO NOT modify if matrix is shared (aliased)
    
    Args:
        matrix: struct scl_sparse_matrix *
        row: long
        data: scl_real_t **
        indices: scl_index_t **
        length: scl_index_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_unsafe_get_row(matrix, row, data, indices, length)


# C: int scl_sparse_unsafe_get_col(struct scl_sparse_matrix * matrix, long col, scl_real_t ** data, scl_index_t ** indices, scl_index_t * length)
_lib.scl_sparse_unsafe_get_col.argtypes = [POINTER(c_void_p), c_long, POINTER(POINTER(c_double)), POINTER(POINTER(c_int64)), POINTER(c_int64)]
_lib.scl_sparse_unsafe_get_col.restype = c_int

def scl_sparse_unsafe_get_col(matrix, col, data, indices, length):
    """
     @brief Get column data pointer for CSC matrix (zero-overhead)
 @param[in] matrix CSC matrix handle (non-null, must be CSC)
 @param[in] col Column index [0, cols)
 @param[out] data Column data pointer (non-null)
 @param[out] indices Column indices pointer (non-null)
 @param[out] length Number of non-zeros in column (non-null)
 @return SCL_OK on success, error code otherwise
 @warning NO bounds checking in release builds
 @warning Pointers invalid after matrix destruction
    
    Args:
        matrix: struct scl_sparse_matrix *
        col: long
        data: scl_real_t **
        indices: scl_index_t **
        length: scl_index_t *
    
    Returns:
        int
    """
    return _lib.scl_sparse_unsafe_get_col(matrix, col, data, indices, length)


# C: int scl_dense_unsafe_get_row(struct scl_dense_matrix * matrix, long row, scl_real_t ** data)
_lib.scl_dense_unsafe_get_row.argtypes = [POINTER(c_void_p), c_long, POINTER(POINTER(c_double))]
_lib.scl_dense_unsafe_get_row.restype = c_int

def scl_dense_unsafe_get_row(matrix, row, data):
    """
     @brief Get mutable row pointer for dense matrix (zero-overhead)
 @param[in] matrix Dense matrix handle (non-null)
 @param[in] row Row index [0, rows)
 @param[out] data Row data pointer (non-null)
 @return SCL_OK on success, error code otherwise
 @warning NO bounds checking in release builds
 @warning Use stride for element access: data[j] = element at (row, j)
 @warning Modifications affect original matrix
    
    Args:
        matrix: struct scl_dense_matrix *
        row: long
        data: scl_real_t **
    
    Returns:
        int
    """
    return _lib.scl_dense_unsafe_get_row(matrix, row, data)


# C: int scl_unsafe_register_buffer(void * ptr, int size)
_lib.scl_unsafe_register_buffer.argtypes = [c_void_p, c_int]
_lib.scl_unsafe_register_buffer.restype = c_int

def scl_unsafe_register_buffer(ptr, size):
    """
     @brief Register external buffer with registry (for ownership transfer)
 @param[in] ptr Pointer to buffer
 @param[in] size Buffer size in bytes
 @return Buffer ID on success, 0 on failure
 @warning Buffer must be allocated with new[] (will use delete[])
 @note Use this to integrate externally-allocated memory with SCL
    
    Args:
        ptr: void *
        size: int
    
    Returns:
        int
    """
    return _lib.scl_unsafe_register_buffer(ptr, size)


# C: int scl_unsafe_create_alias(void * ptr, int buffer_id)
_lib.scl_unsafe_create_alias.argtypes = [c_void_p, c_int]
_lib.scl_unsafe_create_alias.restype = c_int

def scl_unsafe_create_alias(ptr, buffer_id):
    """
     @brief Create alias for shared memory (for zero-copy slicing)
 @param[in] ptr Alias pointer (points somewhere within parent buffer)
 @param[in] buffer_id Parent buffer ID from scl_unsafe_register_buffer
 @return SCL_OK on success, error code otherwise
 @note Alias shares lifetime with parent buffer via reference counting
 @note ptr address implicitly encodes offset - no separate offset needed
    
    Args:
        ptr: void *
        buffer_id: int
    
    Returns:
        int
    """
    return _lib.scl_unsafe_create_alias(ptr, buffer_id)


# C: int scl_unsafe_unregister(void * ptr)
_lib.scl_unsafe_unregister.argtypes = [c_void_p]
_lib.scl_unsafe_unregister.restype = c_int

def scl_unsafe_unregister(ptr):
    """
     @brief Unregister pointer from registry (manual cleanup)
 @param[in] ptr Pointer to unregister
 @return SCL_OK on success, error code otherwise
 @warning Only use if you know what you're doing
 @warning Incorrect usage causes memory leaks or double-frees
    
    Args:
        ptr: void *
    
    Returns:
        int
    """
    return _lib.scl_unsafe_unregister(ptr)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_dense_raw",
    "scl_dense_raw",
    "scl_dense_raw_t",
    "scl_dense_unsafe_from_raw",
    "scl_dense_unsafe_get_raw",
    "scl_dense_unsafe_get_row",
    "scl_sparse_raw",
    "scl_sparse_raw",
    "scl_sparse_raw_t",
    "scl_sparse_unsafe_from_raw",
    "scl_sparse_unsafe_get_col",
    "scl_sparse_unsafe_get_raw",
    "scl_sparse_unsafe_get_row",
    "scl_unsafe_create_alias",
    "scl_unsafe_register_buffer",
    "scl_unsafe_unregister",
]