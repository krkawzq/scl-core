"""
Auto-generated Python bindings for annotation

Source: scl/binding/c_api/annotation.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_annotation_reference_mapping(struct scl_sparse_matrix * query_expression, struct scl_sparse_matrix * reference_expression, const scl_index_t * reference_labels, int n_ref, struct scl_sparse_matrix * query_to_ref_neighbors, long n_query, long n_types, scl_index_t * query_labels, scl_real_t * confidence_scores)
_lib.scl_annotation_reference_mapping.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_long, c_long, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_annotation_reference_mapping.restype = c_int

def scl_annotation_reference_mapping(query_expression, reference_expression, reference_labels, n_ref, query_to_ref_neighbors, n_query, n_types, query_labels, confidence_scores):
    """
     @brief Transfer cell type labels via KNN voting
 @param[in] query_expression Query expression matrix (non-null)
 @param[in] reference_expression Reference expression matrix (non-null)
 @param[in] reference_labels Reference cell type labels [n_ref] (non-null)
 @param[in] n_ref Number of reference cells
 @param[in] query_to_ref_neighbors KNN graph: query -> reference (non-null)
 @param[in] n_query Number of query cells
 @param[in] n_types Number of cell types
 @param[out] query_labels Assigned labels [n_query] (non-null)
 @param[out] confidence_scores Confidence scores [n_query] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        query_expression: struct scl_sparse_matrix *
        reference_expression: struct scl_sparse_matrix *
        reference_labels: const scl_index_t *
        n_ref: int
        query_to_ref_neighbors: struct scl_sparse_matrix *
        n_query: long
        n_types: long
        query_labels: scl_index_t *
        confidence_scores: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_reference_mapping(query_expression, reference_expression, reference_labels, n_ref, query_to_ref_neighbors, n_query, n_types, query_labels, confidence_scores)


# C: int scl_annotation_correlation_assignment(struct scl_sparse_matrix * query_expression, struct scl_sparse_matrix * reference_profiles, long n_query, long n_types, long n_genes, scl_index_t * assigned_labels, scl_real_t * correlation_scores, scl_real_t * all_correlations)
_lib.scl_annotation_correlation_assignment.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_annotation_correlation_assignment.restype = c_int

def scl_annotation_correlation_assignment(query_expression, reference_profiles, n_query, n_types, n_genes, assigned_labels, correlation_scores, all_correlations):
    """
     @brief Assign cell types via correlation with reference profiles
 @param[in] query_expression Query expression matrix (non-null)
 @param[in] reference_profiles Reference type profiles [n_types x n_genes] (non-null)
 @param[in] n_query Number of query cells
 @param[in] n_types Number of cell types
 @param[in] n_genes Number of genes
 @param[out] assigned_labels Assigned labels [n_query] (non-null)
 @param[out] correlation_scores Max correlation per cell [n_query] (non-null)
 @param[out] all_correlations Optional: all correlations [n_query * n_types] (nullable)
 @return SCL_OK on success, error code otherwise
    
    Args:
        query_expression: struct scl_sparse_matrix *
        reference_profiles: struct scl_sparse_matrix *
        n_query: long
        n_types: long
        n_genes: long
        assigned_labels: scl_index_t *
        correlation_scores: scl_real_t *
        all_correlations: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_correlation_assignment(query_expression, reference_profiles, n_query, n_types, n_genes, assigned_labels, correlation_scores, all_correlations)


# C: int scl_annotation_build_reference_profiles(struct scl_sparse_matrix * expression, const scl_index_t * labels, long n_cells, long n_genes, long n_types, scl_real_t * profiles)
_lib.scl_annotation_build_reference_profiles.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p)]
_lib.scl_annotation_build_reference_profiles.restype = c_int

def scl_annotation_build_reference_profiles(expression, labels, n_cells, n_genes, n_types, profiles):
    """
     @brief Compute mean expression profile for each cell type
 @param[in] expression Expression matrix (non-null)
 @param[in] labels Cell type labels [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[in] n_types Number of cell types
 @param[out] profiles Output profiles [n_types * n_genes] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        expression: struct scl_sparse_matrix *
        labels: const scl_index_t *
        n_cells: long
        n_genes: long
        n_types: long
        profiles: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_build_reference_profiles(expression, labels, n_cells, n_genes, n_types, profiles)


# C: int scl_annotation_marker_gene_score(struct scl_sparse_matrix * expression, const scl_index_t *const * marker_genes, const scl_index_t * marker_counts, long n_cells, long n_genes, long n_types, scl_real_t * scores, int normalize)
_lib.scl_annotation_marker_gene_score.argtypes = [POINTER(c_void_p), POINTER(POINTER(c_void_p)), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p), c_int]
_lib.scl_annotation_marker_gene_score.restype = c_int

def scl_annotation_marker_gene_score(expression, marker_genes, marker_counts, n_cells, n_genes, n_types, scores, normalize):
    """
     @brief Score cells based on marker gene expression
 @param[in] expression Expression matrix (non-null)
 @param[in] marker_genes Array of marker gene arrays per type (non-null)
 @param[in] marker_counts Number of markers per type [n_types] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_genes Number of genes
 @param[in] n_types Number of cell types
 @param[out] scores Output scores [n_cells * n_types] (non-null)
 @param[in] normalize SCL_TRUE to apply softmax normalization
 @return SCL_OK on success, error code otherwise
    
    Args:
        expression: struct scl_sparse_matrix *
        marker_genes: const scl_index_t *const *
        marker_counts: const scl_index_t *
        n_cells: long
        n_genes: long
        n_types: long
        scores: scl_real_t *
        normalize: int
    
    Returns:
        int
    """
    return _lib.scl_annotation_marker_gene_score(expression, marker_genes, marker_counts, n_cells, n_genes, n_types, scores, normalize)


# C: int scl_annotation_assign_from_marker_scores(const scl_real_t * scores, long n_cells, long n_types, scl_index_t * labels, scl_real_t * confidence)
_lib.scl_annotation_assign_from_marker_scores.argtypes = [POINTER(c_void_p), c_long, c_long, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_annotation_assign_from_marker_scores.restype = c_int

def scl_annotation_assign_from_marker_scores(scores, n_cells, n_types, labels, confidence):
    """
     @brief Assign labels from marker scores
 @param[in] scores Marker scores [n_cells * n_types] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_types Number of cell types
 @param[out] labels Assigned labels [n_cells] (non-null)
 @param[out] confidence Max score per cell [n_cells] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        scores: const scl_real_t *
        n_cells: long
        n_types: long
        labels: scl_index_t *
        confidence: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_assign_from_marker_scores(scores, n_cells, n_types, labels, confidence)


# C: int scl_annotation_consensus_annotation(const scl_index_t *const * predictions, const scl_real_t *const * confidences, long n_methods, long n_cells, long n_types, scl_index_t * consensus_labels, scl_real_t * consensus_confidence)
_lib.scl_annotation_consensus_annotation.argtypes = [POINTER(POINTER(c_void_p)), POINTER(POINTER(c_void_p)), c_long, c_long, c_long, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_annotation_consensus_annotation.restype = c_int

def scl_annotation_consensus_annotation(predictions, confidences, n_methods, n_cells, n_types, consensus_labels, consensus_confidence):
    """
     @brief Combine predictions from multiple annotation methods
 @param[in] predictions Array of prediction arrays [n_methods] (non-null)
 @param[in] confidences Array of confidence arrays (nullable)
 @param[in] n_methods Number of methods
 @param[in] n_cells Number of cells
 @param[in] n_types Number of cell types
 @param[out] consensus_labels Consensus labels [n_cells] (non-null)
 @param[out] consensus_confidence Consensus confidence [n_cells] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        predictions: const scl_index_t *const *
        confidences: const scl_real_t *const *
        n_methods: long
        n_cells: long
        n_types: long
        consensus_labels: scl_index_t *
        consensus_confidence: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_consensus_annotation(predictions, confidences, n_methods, n_cells, n_types, consensus_labels, consensus_confidence)


# C: int scl_annotation_detect_novel_types(struct scl_sparse_matrix * query_expression, const scl_real_t * confidence_scores, long n_query, double threshold, scl_bool_t * is_novel)
_lib.scl_annotation_detect_novel_types.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_double, POINTER(c_void_p)]
_lib.scl_annotation_detect_novel_types.restype = c_int

def scl_annotation_detect_novel_types(query_expression, confidence_scores, n_query, threshold, is_novel):
    """
     @brief Detect cells that don't match reference types
 @param[in] query_expression Query expression matrix (non-null)
 @param[in] confidence_scores Annotation confidence [n_query] (non-null)
 @param[in] n_query Number of query cells
 @param[in] threshold Confidence threshold (cells below are novel)
 @param[out] is_novel Novel flags [n_query] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        query_expression: struct scl_sparse_matrix *
        confidence_scores: const scl_real_t *
        n_query: long
        threshold: double
        is_novel: scl_bool_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_detect_novel_types(query_expression, confidence_scores, n_query, threshold, is_novel)


# C: int scl_annotation_detect_novel_by_distance(struct scl_sparse_matrix * query_expression, const scl_real_t * reference_profiles, const scl_index_t * assigned_labels, long n_query, long n_types, long n_genes, double distance_threshold, scl_bool_t * is_novel, scl_real_t * distance_to_assigned)
_lib.scl_annotation_detect_novel_by_distance.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, c_double, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_annotation_detect_novel_by_distance.restype = c_int

def scl_annotation_detect_novel_by_distance(query_expression, reference_profiles, assigned_labels, n_query, n_types, n_genes, distance_threshold, is_novel, distance_to_assigned):
    """
     @brief Detect novel types by distance to assigned profile
 @param[in] query_expression Query expression matrix (non-null)
 @param[in] reference_profiles Reference profiles [n_types * n_genes] (non-null)
 @param[in] assigned_labels Assigned labels [n_query] (non-null)
 @param[in] n_query Number of query cells
 @param[in] n_types Number of cell types
 @param[in] n_genes Number of genes
 @param[in] distance_threshold Distance threshold
 @param[out] is_novel Novel flags [n_query] (non-null)
 @param[out] distance_to_assigned Optional: distances [n_query] (nullable)
 @return SCL_OK on success, error code otherwise
    
    Args:
        query_expression: struct scl_sparse_matrix *
        reference_profiles: const scl_real_t *
        assigned_labels: const scl_index_t *
        n_query: long
        n_types: long
        n_genes: long
        distance_threshold: double
        is_novel: scl_bool_t *
        distance_to_assigned: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_detect_novel_by_distance(query_expression, reference_profiles, assigned_labels, n_query, n_types, n_genes, distance_threshold, is_novel, distance_to_assigned)


# C: int scl_annotation_label_propagation(struct scl_sparse_matrix * neighbor_graph, const scl_index_t * initial_labels, long n_cells, long n_types, long max_iter, scl_index_t * final_labels, scl_real_t * label_confidence)
_lib.scl_annotation_label_propagation.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, c_long, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_annotation_label_propagation.restype = c_int

def scl_annotation_label_propagation(neighbor_graph, initial_labels, n_cells, n_types, max_iter, final_labels, label_confidence):
    """
     @brief Propagate labels through neighbor graph
 @param[in] neighbor_graph KNN graph (non-null)
 @param[in] initial_labels Initial labels, -1 for unlabeled [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_types Number of cell types
 @param[in] max_iter Maximum iterations
 @param[out] final_labels Output labels [n_cells] (non-null)
 @param[out] label_confidence Confidence scores [n_cells] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        neighbor_graph: struct scl_sparse_matrix *
        initial_labels: const scl_index_t *
        n_cells: long
        n_types: long
        max_iter: long
        final_labels: scl_index_t *
        label_confidence: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_label_propagation(neighbor_graph, initial_labels, n_cells, n_types, max_iter, final_labels, label_confidence)


# C: int scl_annotation_quality_metrics(const scl_index_t * predicted_labels, const scl_index_t * true_labels, long n_cells, long n_types, scl_real_t * accuracy, scl_real_t * macro_f1, scl_real_t * per_class_f1)
_lib.scl_annotation_quality_metrics.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_annotation_quality_metrics.restype = c_int

def scl_annotation_quality_metrics(predicted_labels, true_labels, n_cells, n_types, accuracy, macro_f1, per_class_f1):
    """
     @brief Compute annotation quality metrics
 @param[in] predicted_labels Predicted labels [n_cells] (non-null)
 @param[in] true_labels Ground truth labels [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_types Number of cell types
 @param[out] accuracy Overall accuracy (non-null)
 @param[out] macro_f1 Macro-averaged F1 score (non-null)
 @param[out] per_class_f1 Optional: per-class F1 [n_types] (nullable)
 @return SCL_OK on success, error code otherwise
    
    Args:
        predicted_labels: const scl_index_t *
        true_labels: const scl_index_t *
        n_cells: long
        n_types: long
        accuracy: scl_real_t *
        macro_f1: scl_real_t *
        per_class_f1: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_quality_metrics(predicted_labels, true_labels, n_cells, n_types, accuracy, macro_f1, per_class_f1)


# C: int scl_annotation_confusion_matrix(const scl_index_t * predicted_labels, const scl_index_t * true_labels, long n_cells, long n_types, scl_index_t * confusion)
_lib.scl_annotation_confusion_matrix.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, c_long, POINTER(c_void_p)]
_lib.scl_annotation_confusion_matrix.restype = c_int

def scl_annotation_confusion_matrix(predicted_labels, true_labels, n_cells, n_types, confusion):
    """
     @brief Compute confusion matrix
 @param[in] predicted_labels Predicted labels [n_cells] (non-null)
 @param[in] true_labels Ground truth labels [n_cells] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_types Number of cell types
 @param[out] confusion Confusion matrix [n_types * n_types] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        predicted_labels: const scl_index_t *
        true_labels: const scl_index_t *
        n_cells: long
        n_types: long
        confusion: scl_index_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_confusion_matrix(predicted_labels, true_labels, n_cells, n_types, confusion)


# C: int scl_annotation_entropy(const scl_real_t * type_probabilities, long n_cells, long n_types, scl_real_t * entropy)
_lib.scl_annotation_entropy.argtypes = [POINTER(c_void_p), c_long, c_long, POINTER(c_void_p)]
_lib.scl_annotation_entropy.restype = c_int

def scl_annotation_entropy(type_probabilities, n_cells, n_types, entropy):
    """
     @brief Compute entropy-based annotation uncertainty
 @param[in] type_probabilities Type probabilities [n_cells * n_types] (non-null)
 @param[in] n_cells Number of cells
 @param[in] n_types Number of cell types
 @param[out] entropy Entropy values [n_cells] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        type_probabilities: const scl_real_t *
        n_cells: long
        n_types: long
        entropy: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_annotation_entropy(type_probabilities, n_cells, n_types, entropy)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_annotation_assign_from_marker_scores",
    "scl_annotation_build_reference_profiles",
    "scl_annotation_confusion_matrix",
    "scl_annotation_consensus_annotation",
    "scl_annotation_correlation_assignment",
    "scl_annotation_detect_novel_by_distance",
    "scl_annotation_detect_novel_types",
    "scl_annotation_entropy",
    "scl_annotation_label_propagation",
    "scl_annotation_marker_gene_score",
    "scl_annotation_quality_metrics",
    "scl_annotation_reference_mapping",
]