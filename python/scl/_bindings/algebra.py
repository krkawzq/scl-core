"""
Auto-generated Python bindings for algebra

Source: scl/binding/c_api/algebra.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_algebra_spmv(struct scl_sparse_matrix * A, const scl_real_t * x, int x_size, scl_real_t * y, int y_size, double alpha, double beta)
_lib.scl_algebra_spmv.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, c_double, c_double]
_lib.scl_algebra_spmv.restype = c_int

def scl_algebra_spmv(A, x, x_size, y, y_size, alpha, beta):
    """
     @brief General SpMV: y = alpha * A * x + beta * y
 @param[in] A Sparse matrix (non-null, CSR or CSC)
 @param[in] x Input vector [secondary_dim] (non-null)
 @param[in] x_size Size of x (must be >= A.secondary_dim)
 @param[in,out] y Output vector [primary_dim] (non-null)
 @param[in] y_size Size of y (must be >= A.primary_dim)
 @param[in] alpha Scaling factor for A*x
 @param[in] beta Scaling factor for y
 @return SCL_OK on success, error code otherwise
 @note y is modified in-place
 @note For CSR: primary=rows, secondary=cols
 @note For CSC: primary=cols, secondary=rows
    
    Args:
        A: struct scl_sparse_matrix *
        x: const scl_real_t *
        x_size: int
        y: scl_real_t *
        y_size: int
        alpha: double
        beta: double
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmv(A, x, x_size, y, y_size, alpha, beta)


# C: int scl_algebra_spmv_simple(struct scl_sparse_matrix * A, const scl_real_t * x, int x_size, scl_real_t * y, int y_size)
_lib.scl_algebra_spmv_simple.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int]
_lib.scl_algebra_spmv_simple.restype = c_int

def scl_algebra_spmv_simple(A, x, x_size, y, y_size):
    """
     @brief Simple SpMV: y = A * x
    
    Args:
        A: struct scl_sparse_matrix *
        x: const scl_real_t *
        x_size: int
        y: scl_real_t *
        y_size: int
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmv_simple(A, x, x_size, y, y_size)


# C: int scl_algebra_spmv_scaled(struct scl_sparse_matrix * A, const scl_real_t * x, int x_size, scl_real_t * y, int y_size, double alpha)
_lib.scl_algebra_spmv_scaled.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, c_double]
_lib.scl_algebra_spmv_scaled.restype = c_int

def scl_algebra_spmv_scaled(A, x, x_size, y, y_size, alpha):
    """
     @brief Scaled SpMV: y = alpha * A * x
    
    Args:
        A: struct scl_sparse_matrix *
        x: const scl_real_t *
        x_size: int
        y: scl_real_t *
        y_size: int
        alpha: double
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmv_scaled(A, x, x_size, y, y_size, alpha)


# C: int scl_algebra_spmv_add(struct scl_sparse_matrix * A, const scl_real_t * x, int x_size, scl_real_t * y, int y_size)
_lib.scl_algebra_spmv_add.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int]
_lib.scl_algebra_spmv_add.restype = c_int

def scl_algebra_spmv_add(A, x, x_size, y, y_size):
    """
     @brief Additive SpMV: y += A * x
    
    Args:
        A: struct scl_sparse_matrix *
        x: const scl_real_t *
        x_size: int
        y: scl_real_t *
        y_size: int
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmv_add(A, x, x_size, y, y_size)


# C: int scl_algebra_spmv_transpose(struct scl_sparse_matrix * A, const scl_real_t * x, int x_size, scl_real_t * y, int y_size, double alpha, double beta)
_lib.scl_algebra_spmv_transpose.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, c_double, c_double]
_lib.scl_algebra_spmv_transpose.restype = c_int

def scl_algebra_spmv_transpose(A, x, x_size, y, y_size, alpha, beta):
    """
     @brief Transposed SpMV: y = alpha * A^T * x + beta * y
 @param[in] A Sparse matrix (non-null)
 @param[in] x Input vector [primary_dim] (non-null)
 @param[in] x_size Size of x
 @param[in,out] y Output vector [secondary_dim] (non-null)
 @param[in] y_size Size of y
 @param[in] alpha Scaling factor
 @param[in] beta Scaling factor
 @return SCL_OK on success, error code otherwise
 @note Uses atomic accumulation for thread safety
    
    Args:
        A: struct scl_sparse_matrix *
        x: const scl_real_t *
        x_size: int
        y: scl_real_t *
        y_size: int
        alpha: double
        beta: double
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmv_transpose(A, x, x_size, y, y_size, alpha, beta)


# C: int scl_algebra_spmv_transpose_simple(struct scl_sparse_matrix * A, const scl_real_t * x, int x_size, scl_real_t * y, int y_size)
_lib.scl_algebra_spmv_transpose_simple.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int]
_lib.scl_algebra_spmv_transpose_simple.restype = c_int

def scl_algebra_spmv_transpose_simple(A, x, x_size, y, y_size):
    """
     @brief Simple transposed SpMV: y = A^T * x
    
    Args:
        A: struct scl_sparse_matrix *
        x: const scl_real_t *
        x_size: int
        y: scl_real_t *
        y_size: int
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmv_transpose_simple(A, x, x_size, y, y_size)


# C: int scl_algebra_spmm(struct scl_sparse_matrix * A, const scl_real_t * X, long n_cols, scl_real_t * Y, double alpha, double beta)
_lib.scl_algebra_spmm.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_long, POINTER(c_void_p), c_double, c_double]
_lib.scl_algebra_spmm.restype = c_int

def scl_algebra_spmm(A, X, n_cols, Y, alpha, beta):
    """
     @brief SpMM: Y = alpha * A * X + beta * Y
 @param[in] A Sparse matrix (non-null)
 @param[in] X Dense matrix [secondary_dim x n_cols], row-major (non-null)
 @param[in] n_cols Number of columns in X and Y
 @param[in,out] Y Dense matrix [primary_dim x n_cols], row-major (non-null)
 @param[in] alpha Scaling factor for A*X
 @param[in] beta Scaling factor for Y
 @return SCL_OK on success, error code otherwise
 @note Y is modified in-place
 @note Uses cache-aware tiling for performance
    
    Args:
        A: struct scl_sparse_matrix *
        X: const scl_real_t *
        n_cols: long
        Y: scl_real_t *
        alpha: double
        beta: double
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmm(A, X, n_cols, Y, alpha, beta)


# C: int scl_algebra_spmv_fused_linear(struct scl_sparse_matrix * A, const scl_real_t * x, int x_size, const scl_real_t * z, int z_size, scl_real_t * y, int y_size, double alpha, double beta, double gamma)
_lib.scl_algebra_spmv_fused_linear.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, POINTER(c_void_p), c_int, c_double, c_double, c_double]
_lib.scl_algebra_spmv_fused_linear.restype = c_int

def scl_algebra_spmv_fused_linear(A, x, x_size, z, z_size, y, y_size, alpha, beta, gamma):
    """
     @brief Fused SpMV: y = alpha * A * x + beta * A * z + gamma * y
 @param[in] A Sparse matrix (non-null)
 @param[in] x First input vector (non-null)
 @param[in] x_size Size of x
 @param[in] z Second input vector (non-null)
 @param[in] z_size Size of z
 @param[in,out] y Output vector (non-null)
 @param[in] y_size Size of y
 @param[in] alpha Scaling for A*x
 @param[in] beta Scaling for A*z
 @param[in] gamma Scaling for y
 @return SCL_OK on success, error code otherwise
 @note Fuses two SpMV operations for better cache utilization
    
    Args:
        A: struct scl_sparse_matrix *
        x: const scl_real_t *
        x_size: int
        z: const scl_real_t *
        z_size: int
        y: scl_real_t *
        y_size: int
        alpha: double
        beta: double
        gamma: double
    
    Returns:
        int
    """
    return _lib.scl_algebra_spmv_fused_linear(A, x, x_size, z, z_size, y, y_size, alpha, beta, gamma)


# C: int scl_algebra_row_norms(struct scl_sparse_matrix * A, scl_real_t * norms, int norms_size)
_lib.scl_algebra_row_norms.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_algebra_row_norms.restype = c_int

def scl_algebra_row_norms(A, norms, norms_size):
    """
     @brief Compute L2 norm of each row/column
 @param[in] A Sparse matrix (non-null)
 @param[out] norms Output array [primary_dim] (non-null)
 @param[in] norms_size Size of norms array
 @return SCL_OK on success, error code otherwise
    
    Args:
        A: struct scl_sparse_matrix *
        norms: scl_real_t *
        norms_size: int
    
    Returns:
        int
    """
    return _lib.scl_algebra_row_norms(A, norms, norms_size)


# C: int scl_algebra_row_sums(struct scl_sparse_matrix * A, scl_real_t * sums, int sums_size)
_lib.scl_algebra_row_sums.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_algebra_row_sums.restype = c_int

def scl_algebra_row_sums(A, sums, sums_size):
    """
     @brief Compute sum of each row/column
 @param[in] A Sparse matrix (non-null)
 @param[out] sums Output array [primary_dim] (non-null)
 @param[in] sums_size Size of sums array
 @return SCL_OK on success, error code otherwise
    
    Args:
        A: struct scl_sparse_matrix *
        sums: scl_real_t *
        sums_size: int
    
    Returns:
        int
    """
    return _lib.scl_algebra_row_sums(A, sums, sums_size)


# C: int scl_algebra_extract_diagonal(struct scl_sparse_matrix * A, scl_real_t * diag, int diag_size)
_lib.scl_algebra_extract_diagonal.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_algebra_extract_diagonal.restype = c_int

def scl_algebra_extract_diagonal(A, diag, diag_size):
    """
     @brief Extract diagonal elements
 @param[in] A Sparse matrix (non-null)
 @param[out] diag Output array [min(rows, cols)] (non-null)
 @param[in] diag_size Size of diag array
 @return SCL_OK on success, error code otherwise
    
    Args:
        A: struct scl_sparse_matrix *
        diag: scl_real_t *
        diag_size: int
    
    Returns:
        int
    """
    return _lib.scl_algebra_extract_diagonal(A, diag, diag_size)


# C: int scl_algebra_scale_rows(struct scl_sparse_matrix * A, const scl_real_t * scale_factors, int scale_factors_size)
_lib.scl_algebra_scale_rows.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int]
_lib.scl_algebra_scale_rows.restype = c_int

def scl_algebra_scale_rows(A, scale_factors, scale_factors_size):
    """
     @brief Scale rows/columns in-place: A_i = scale_factors[i] * A_i
 @param[in,out] A Sparse matrix (non-null, modified in-place)
 @param[in] scale_factors Scaling factors [primary_dim] (non-null)
 @param[in] scale_factors_size Size of scale_factors array
 @return SCL_OK on success, error code otherwise
 @note Modifies matrix in-place - NOT thread-safe
    
    Args:
        A: struct scl_sparse_matrix *
        scale_factors: const scl_real_t *
        scale_factors_size: int
    
    Returns:
        int
    """
    return _lib.scl_algebra_scale_rows(A, scale_factors, scale_factors_size)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_algebra_extract_diagonal",
    "scl_algebra_row_norms",
    "scl_algebra_row_sums",
    "scl_algebra_scale_rows",
    "scl_algebra_spmm",
    "scl_algebra_spmv",
    "scl_algebra_spmv_add",
    "scl_algebra_spmv_fused_linear",
    "scl_algebra_spmv_scaled",
    "scl_algebra_spmv_simple",
    "scl_algebra_spmv_transpose",
    "scl_algebra_spmv_transpose_simple",
]