"""
Auto-generated Python bindings for association

Source: scl/binding/c_api/association.h
Generated by: generate_bindings.py

DO NOT EDIT - This file is automatically generated.
"""

from __future__ import annotations

from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    c_bool,
    c_char,
    c_char_p,
    c_double,
    c_float,
    c_int,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_long,
    c_longlong,
    c_short,
    c_size_t,
    c_ssize_t,
    c_ubyte,
    c_uint,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_ulong,
    c_ulonglong,
    c_ushort,
    c_void_p,
    c_wchar_p,
)
from typing import Any, Optional

from .._loader import get_library

# Load the native library
_lib = get_library()


# ===========================================================================
# Functions
# ===========================================================================

# C: int scl_association_gene_peak_correlation(struct scl_sparse_matrix * rna_expression, struct scl_sparse_matrix * atac_accessibility, scl_index_t * gene_indices, scl_index_t * peak_indices, scl_real_t * correlations, scl_size_t * n_correlations, double min_correlation)
_lib.scl_association_gene_peak_correlation.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_double]
_lib.scl_association_gene_peak_correlation.restype = c_int

def scl_association_gene_peak_correlation(rna_expression, atac_accessibility, gene_indices, peak_indices, correlations, n_correlations, min_correlation):
    """
     @brief Compute correlations between all gene-peak pairs
 @param[in] rna_expression RNA expression matrix (non-null)
 @param[in] atac_accessibility ATAC accessibility matrix (non-null)
 @param[out] gene_indices Gene indices for significant pairs (non-null)
 @param[out] peak_indices Peak indices for significant pairs (non-null)
 @param[out] correlations Correlation values (non-null)
 @param[out] n_correlations Number of significant correlations (non-null)
 @param[in] min_correlation Minimum absolute correlation threshold
 @return SCL_OK on success, error code otherwise
 @note Caller must pre-allocate arrays with sufficient size
    
    Args:
        rna_expression: struct scl_sparse_matrix *
        atac_accessibility: struct scl_sparse_matrix *
        gene_indices: scl_index_t *
        peak_indices: scl_index_t *
        correlations: scl_real_t *
        n_correlations: scl_size_t *
        min_correlation: double
    
    Returns:
        int
    """
    return _lib.scl_association_gene_peak_correlation(rna_expression, atac_accessibility, gene_indices, peak_indices, correlations, n_correlations, min_correlation)


# C: int scl_association_cis_regulatory(struct scl_sparse_matrix * rna_expression, struct scl_sparse_matrix * atac_accessibility, const scl_index_t * gene_indices, const scl_index_t * peak_indices, int n_pairs, scl_real_t * correlations, scl_real_t * p_values)
_lib.scl_association_cis_regulatory.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_int, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_association_cis_regulatory.restype = c_int

def scl_association_cis_regulatory(rna_expression, atac_accessibility, gene_indices, peak_indices, n_pairs, correlations, p_values):
    """
     @brief Compute cis-regulatory associations for specific gene-peak pairs
 @param[in] rna_expression RNA expression matrix (non-null)
 @param[in] atac_accessibility ATAC accessibility matrix (non-null)
 @param[in] gene_indices Gene indices to test [n_pairs] (non-null)
 @param[in] peak_indices Peak indices to test [n_pairs] (non-null)
 @param[in] n_pairs Number of pairs to test
 @param[out] correlations Pearson correlations [n_pairs] (non-null)
 @param[out] p_values Statistical p-values [n_pairs] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        rna_expression: struct scl_sparse_matrix *
        atac_accessibility: struct scl_sparse_matrix *
        gene_indices: const scl_index_t *
        peak_indices: const scl_index_t *
        n_pairs: int
        correlations: scl_real_t *
        p_values: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_association_cis_regulatory(rna_expression, atac_accessibility, gene_indices, peak_indices, n_pairs, correlations, p_values)


# C: int scl_association_enhancer_gene_link(struct scl_sparse_matrix * rna, struct scl_sparse_matrix * atac, double correlation_threshold, scl_index_t * link_genes, scl_index_t * link_peaks, scl_real_t * link_correlations, scl_size_t * n_links)
_lib.scl_association_enhancer_gene_link.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_double, POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_association_enhancer_gene_link.restype = c_int

def scl_association_enhancer_gene_link(rna, atac, correlation_threshold, link_genes, link_peaks, link_correlations, n_links):
    """
     @brief Identify enhancer-gene links via correlation
 @param[in] rna RNA expression matrix (non-null)
 @param[in] atac ATAC accessibility matrix (non-null)
 @param[in] correlation_threshold Minimum correlation for link
 @param[out] link_genes Gene indices [n_links] (non-null)
 @param[out] link_peaks Peak indices [n_links] (non-null)
 @param[out] link_correlations Correlation values [n_links] (non-null)
 @param[out] n_links Number of links found (non-null)
 @return SCL_OK on success, error code otherwise
 @note Only positive correlations are returned
    
    Args:
        rna: struct scl_sparse_matrix *
        atac: struct scl_sparse_matrix *
        correlation_threshold: double
        link_genes: scl_index_t *
        link_peaks: scl_index_t *
        link_correlations: scl_real_t *
        n_links: scl_size_t *
    
    Returns:
        int
    """
    return _lib.scl_association_enhancer_gene_link(rna, atac, correlation_threshold, link_genes, link_peaks, link_correlations, n_links)


# C: int scl_association_multimodal_neighbors(struct scl_sparse_matrix * modality1, struct scl_sparse_matrix * modality2, double weight1, double weight2, long k, scl_index_t * neighbor_indices, scl_real_t * neighbor_distances)
_lib.scl_association_multimodal_neighbors.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_double, c_double, c_long, POINTER(c_void_p), POINTER(c_void_p)]
_lib.scl_association_multimodal_neighbors.restype = c_int

def scl_association_multimodal_neighbors(modality1, modality2, weight1, weight2, k, neighbor_indices, neighbor_distances):
    """
     @brief Compute nearest neighbors using combined distance from two modalities
 @param[in] modality1 First modality data (non-null)
 @param[in] modality2 Second modality data (non-null)
 @param[in] weight1 Weight for modality 1 distance
 @param[in] weight2 Weight for modality 2 distance
 @param[in] k Number of neighbors
 @param[out] neighbor_indices Neighbor indices [n_cells * k] (non-null)
 @param[out] neighbor_distances Neighbor distances [n_cells * k] (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        modality1: struct scl_sparse_matrix *
        modality2: struct scl_sparse_matrix *
        weight1: double
        weight2: double
        k: long
        neighbor_indices: scl_index_t *
        neighbor_distances: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_association_multimodal_neighbors(modality1, modality2, weight1, weight2, k, neighbor_indices, neighbor_distances)


# C: int scl_association_feature_coupling(struct scl_sparse_matrix * modality1, struct scl_sparse_matrix * modality2, scl_index_t * feature1_indices, scl_index_t * feature2_indices, scl_real_t * coupling_scores, scl_size_t * n_couplings, double min_score)
_lib.scl_association_feature_coupling.argtypes = [POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), POINTER(c_void_p), c_double]
_lib.scl_association_feature_coupling.restype = c_int

def scl_association_feature_coupling(modality1, modality2, feature1_indices, feature2_indices, coupling_scores, n_couplings, min_score):
    """
     @brief Find coupled features across modalities (Spearman correlation)
 @param[in] modality1 First modality data (non-null)
 @param[in] modality2 Second modality data (non-null)
 @param[out] feature1_indices Feature indices from modality1 (non-null)
 @param[out] feature2_indices Feature indices from modality2 (non-null)
 @param[out] coupling_scores Coupling scores (non-null)
 @param[out] n_couplings Number of significant couplings (non-null)
 @param[in] min_score Minimum coupling score threshold
 @return SCL_OK on success, error code otherwise
    
    Args:
        modality1: struct scl_sparse_matrix *
        modality2: struct scl_sparse_matrix *
        feature1_indices: scl_index_t *
        feature2_indices: scl_index_t *
        coupling_scores: scl_real_t *
        n_couplings: scl_size_t *
        min_score: double
    
    Returns:
        int
    """
    return _lib.scl_association_feature_coupling(modality1, modality2, feature1_indices, feature2_indices, coupling_scores, n_couplings, min_score)


# C: int scl_association_peak_to_gene_activity(struct scl_sparse_matrix * atac, const scl_index_t * peak_to_gene_map, int n_peaks, int n_genes, scl_real_t * gene_activity)
_lib.scl_association_peak_to_gene_activity.argtypes = [POINTER(c_void_p), POINTER(c_void_p), c_int, c_int, POINTER(c_void_p)]
_lib.scl_association_peak_to_gene_activity.restype = c_int

def scl_association_peak_to_gene_activity(atac, peak_to_gene_map, n_peaks, n_genes, gene_activity):
    """
     @brief Compute gene activity scores from peak accessibility
 @param[in] atac ATAC accessibility matrix (non-null)
 @param[in] peak_to_gene_map Peak to gene mapping [n_peaks] (non-null)
 @param[in] n_peaks Number of peaks
 @param[in] n_genes Number of genes
 @param[out] gene_activity Gene activity matrix [n_cells * n_genes] (non-null)
 @return SCL_OK on success, error code otherwise
 @note peak_to_gene_map[i] = gene index for peak i, or -1 if no mapping
    
    Args:
        atac: struct scl_sparse_matrix *
        peak_to_gene_map: const scl_index_t *
        n_peaks: int
        n_genes: int
        gene_activity: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_association_peak_to_gene_activity(atac, peak_to_gene_map, n_peaks, n_genes, gene_activity)


# C: int scl_association_correlation_in_subset(struct scl_sparse_matrix * data1, long feature1, struct scl_sparse_matrix * data2, long feature2, const scl_index_t * cell_indices, int n_subset, scl_real_t * correlation)
_lib.scl_association_correlation_in_subset.argtypes = [POINTER(c_void_p), c_long, POINTER(c_void_p), c_long, POINTER(c_void_p), c_int, POINTER(c_void_p)]
_lib.scl_association_correlation_in_subset.restype = c_int

def scl_association_correlation_in_subset(data1, feature1, data2, feature2, cell_indices, n_subset, correlation):
    """
     @brief Compute correlation for specific feature pair in cell subset
 @param[in] data1 First modality data (non-null)
 @param[in] feature1 Feature index in data1
 @param[in] data2 Second modality data (non-null)
 @param[in] feature2 Feature index in data2
 @param[in] cell_indices Cell subset indices [n_subset] (non-null)
 @param[in] n_subset Number of cells in subset
 @param[out] correlation Output correlation value (non-null)
 @return SCL_OK on success, error code otherwise
    
    Args:
        data1: struct scl_sparse_matrix *
        feature1: long
        data2: struct scl_sparse_matrix *
        feature2: long
        cell_indices: const scl_index_t *
        n_subset: int
        correlation: scl_real_t *
    
    Returns:
        int
    """
    return _lib.scl_association_correlation_in_subset(data1, feature1, data2, feature2, cell_indices, n_subset, correlation)


# ===========================================================================
# Exports
# ===========================================================================

__all__ = [
    "scl_association_cis_regulatory",
    "scl_association_correlation_in_subset",
    "scl_association_enhancer_gene_link",
    "scl_association_feature_coupling",
    "scl_association_gene_peak_correlation",
    "scl_association_multimodal_neighbors",
    "scl_association_peak_to_gene_activity",
]